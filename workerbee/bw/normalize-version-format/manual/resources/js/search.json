[[{"l":"Intro to WorkerBee library","p":["A powerful and flexible Hive automation library.","WorkerBee, based on wax, provides a simple yet powerful interface to interact with the Hive blockchain, allowing you to build sophisticated bots and automation scripts with ease."]},{"l":"✨ Features","p":["No More Endless Loops!\uD83D\uDD04 Just say what you want to listen to - WorkerBee does all the waiting and event handling behind the scenes.","No Blockchain Headaches!\uD83E\uDDE9 Forget complicated APIs and coding tricks. Write logic much like you would on regular web apps (think: “When a new post appears by Alice, send me a ping!”).","Keep Your Sandbox Clean\uD83E\uDDFC WorkerBee shields your code from the messy details of blockchain data, so your app stays flexible and easy-to-maintain.","One Interface, Many Sources\uD83D\uDDC3️ Switch from live blockchain data to a historical database or new data source (e.g. SQL) - all without changing your app’s logic!","Easy to Expand\uD83D\uDCC8 Start simple but add new events, rules, or channels as your needs grow.","Fully typed ℹ️ Library APIs have well defined types and functional interfaces with special support for IDE IntelliSense","This document contains executable examples that readers can directly interact with. When first opened, an example will automatically execute. You can also modify an example and re-run it. To re-run an example after modifying it, press the up-arrow in the terminal window to fetch the last command in the command line history (this is the command used to originally execute the example).","Start by exploring the WorkerBee Interfaces Reference:","Interfaces Reference"]}],[{"l":"Documentation Overview","p":["Welcome to the complete documentation for WorkerBee! This section provides comprehensive guides, examples, and references for building powerful blockchain applications."]},{"i":"rocket-getting-started","l":"\uD83D\uDE80 Getting Started","p":["New to WorkerBee? Start here!","Getting Started Guide","Learn the basics of WorkerBee, installation, and your first blockchain observer."]},{"i":"mortar_board-learning-path","l":"\uD83C\uDF93 Learning Path"},{"l":"Beginner","p":["Getting Started- Basic concepts and first examples","Base Configuration- Setting up for your environment","Filters & Conditions- Monitoring blockchain events"]},{"l":"Intermediate","p":["Data Providers- Working with blockchain data","Common Patterns- Best practices and reusable solutions"]},{"l":"Advanced","p":["Past Data- Leveraging historical blockchain data","Core Architecture- Understanding the internals","Advanced Examples- Real-world applications","API Reference- Complete technical reference"]},{"i":"sparkles-essential-concepts","l":"✨ Essential Concepts","p":["Observer Pattern: Reactive programming for blockchain events","Fluent API: Chain methods to build complex observations","Smart Caching: Automatic optimization of API calls","Concurrent Processing: Filters and providers run in parallel","Error Handling: Built-in retry logic and failover mechanisms","Fully typed: Library APIs have well defined types and functional interfaces with special support for IDE IntelliSense:"]},{"i":"question-need-help","l":"❓ Need Help?","p":["Issues & Bugs: WorkerBee GitLab Issues","Hive Community: Hive.blog posts tagged with workerbee"]},{"i":"star-what-makes-workerbee-special","l":"⭐ What Makes WorkerBee Special?"},{"l":"For Blockchain Developers","p":["No More Polling Loops: Declarative event monitoring","Built-in Optimizations: Smart caching and concurrent processing","Type Safety: Full TypeScript support with excellent IDE integration","Multiple Data Sources: Switch between RPC, REST, SQL without code changes"]},{"l":"For Application Developers","p":["Web-like APIs: Familiar reactive patterns, no blockchain complexity","Clean Data Models: Normalized objects instead of raw blockchain data","Error Resilience: Automatic retry and failover handling","Performance: Up to 50% fewer API calls through intelligent caching","Start your blockchain application journey with WorkerBee today! \uD83D\uDC1D"]}],[{"l":"Getting Started","p":["Welcome to WorkerBee, the powerful TypeScript library that makes building Hive blockchain bots as easy as writing regular web applications!"]},{"i":"package-installation","l":"\uD83D\uDCE6 Installation","p":["Install WorkerBee:","View WorkerBee package on npmjs \uD83E\uDC6D","You can also use other package managers, such as: npm or yarn"]},{"i":"zap-quick-start","l":"⚡ Quick Start","p":["Here's a simple example that initializes and starts the bot:"]},{"i":"building_construction-core-concepts","l":"\uD83C\uDFD7️ Core Concepts"},{"l":"Observer Pattern","p":["WorkerBee uses the Observer pattern, similar to modern reactive libraries. You define what you want to observe, and WorkerBee handles how to monitor the blockchain."]},{"l":"Fluent API","p":["Build complex queries using method chaining, e.g.:"]},{"i":"bulb-key-benefits","l":"\uD83D\uDCA1 Key Benefits"},{"l":"No More Polling Loops","p":["Instead of writing endless while loops and managing timers, just declare what you want to observe:"]},{"l":"Error Handling","p":["WorkerBee handles network errors, API limits, and blockchain reorganizations automatically:"]},{"l":"Flexible Data Sources","p":["Switch between live blockchain data and historical analysis without changing your code:"]},{"l":"Broadcasting Transactions","p":["WorkerBee's broadcast method goes beyond regular broadcasting by providing L1 blockchain validation:","Key Difference from Regular Broadcasting:","Regular broadcast: Only ensures the transaction reaches the node and is valid","WorkerBee broadcast: Guarantees the transaction was propagated and applied by witnesses in a block by verifying its actual presence in the blockchain","Options explained:","verifySignatures: Checks if transaction signatures and their order/count remain unchanged after blockchain inclusion (detects tampering, not pre-broadcast validation)","expireInMs: Maximum time to wait for the transaction to appear in a block (usually ~ 3 seconds). If timeout occurs, the transaction may still appear later in the blockchain, but an error is thrown"]},{"l":"Block Iteration","p":["WorkerBee provides powerful async iterators for processing blockchain data in real-time:","Error Handling Behavior:","for await (const block of bot)- Ignores all errors(uses default async iterator)","bot.iterate()(no arguments) - Ignores all errors","bot.iterate(callback)- Errors are passed to the callback function","bot.iterate(true)- Errors are thrown and can be caught with try-catch","Key Features:","Real-time processing: Automatically waits for new blocks as they arrive","Memory efficient: Uses promise queues to handle backpressure when processing is slower than block production","Automatic cleanup: Properly unsubscribes from observers when iteration is interrupted","Flexible error handling: Support for callbacks, boolean flags, or try-catch patterns"]}],[{"l":"Base Configuration","p":["Configure WorkerBee for different environments and use cases."]},{"i":"wrench-basic-configuration","l":"\uD83D\uDD27 Basic Configuration"},{"l":"WorkerBee Config Interface"},{"i":"satellite-api-endpoint-configuration","l":"\uD83D\uDEF0️ API Endpoint Configuration"},{"l":"Popular Hive API Endpoints","p":["You can find a full list of Hive API endpoints in the official Hive documentation and then choose the one that best fits your needs:","WorkerBee with standard filters requires connection to a consensus node(full node) for optimal functionality. Consensus nodes provide:","Complete blockchain history and block data access","Real-time streaming of all operations and transactions","Full account state and balance information","Historical data for analysis and monitoring","Light API nodes may have limited functionality with WorkerBee filters, particularly those monitoring blockchain infrastructure, account changes, or requiring historical data access."]},{"l":"Recommended Consensus Nodes","p":["The following public endpoints provide full consensus node functionality:","https://api.hive.blog- Primary Hive API (consensus node)","https://api.openhive.network- OpenHive network (consensus node)","https://anyx.io- Community consensus node","https://rpc.ausbit.dev- Australian consensus node","https://api.hive.blue- Consensus node with high availability","Choose an endpoint geographically close to your application for better performance."]},{"i":"clock3-timing-configuration","l":"\uD83D\uDD52 Timing Configuration"},{"l":"Timeout Configuration","p":["Sometimes you need to adjust the timeout settings based on your network conditions:","Setting apiTimeout to 0 disables the timeout, which can be useful for long-running requests or low-quality networks."]},{"i":"ringed_planet-wax-chain-usage","l":"\uD83E\uDE90 Wax chain usage","p":["As shown in the WorkerBee Config Interface, you can provide an explicit chain that will be used for performing all API calls and data transformations. The Wax Chain instance is also accessible via the chain property on the WorkerBee instance.","If an explicit chain is not provided (which is optional), a default chain instance will be created when the start method is called.","Remember that before starting the bot, if no explicit chain was provided, the chain property will be undefined."]}],[{"l":"Filters & Conditions","p":["Filters are the core of WorkerBee's event system. They define when your observers should be triggered by evaluating blockchain conditions in real-time."]},{"i":"mag-filter-overview","l":"\uD83D\uDD0D Filter Overview","p":["Filters monitor the blockchain for specific events and trigger your callbacks when conditions are met. They run concurrently and use smart caching to minimize API calls.","Below you can find a diagram presenting the set of predefined filter categories:","WorkerBee filter categories"]},{"l":"Basic Filter Usage"},{"i":"link-logical-operators","l":"\uD83D\uDD17 Logical Operators","p":["WorkerBee supports powerful logical operators to combine multiple filter conditions using AND and OR operations."]},{"l":"AND Operator (Explicit)","p":["The AND operator requires ALL specified conditions to be met simultaneously. Use the explicit .and method to combine filters."]},{"l":"OR Operator (Implicit & Explicit)","p":["The OR operator triggers when ANY of the specified conditions is met."]},{"l":"Implicit OR (Multiple accounts)","p":["When you pass multiple accounts to a single filter method, WorkerBee automatically applies OR logic between them:"]},{"l":"Explicit OR (Different filter types)","p":["Use the explicit .or method to combine different types of filters:"]},{"i":"scales-operator-precedence","l":"⚖️ Operator Precedence","p":["AND takes precedence over OR- this is crucial for understanding complex filter combinations."]},{"l":"How Precedence Works","p":["WorkerBee processes filters by grouping OR operations first, then combining these groups with AND logic:"]},{"l":"Complex Combinations","p":["When chaining multiple AND operations, each .and creates a new group:"]},{"i":"books-complete-reference","l":"\uD83D\uDCDA Complete Reference","p":["For comprehensive examples of all available filters, check out the complete API reference:","Browse All Filter Examples in API Reference"]}],[{"l":"Data Providers","p":["Data Providers are WorkerBee's powerful data transformation layer that intelligently gathers, processes, and normalizes blockchain data into clean, type-safe objects for your application. They execute only when filters match, ensuring optimal performance and minimal resource usage."]},{"i":"mag-provider-overview","l":"\uD83D\uDD0D Provider Overview","p":["Providers transform raw blockchain data into structured TypeScript objects, running concurrently with filters and automatically benefiting from WorkerBee's advanced caching system. They provide rich contextual data that complements the events detected by filters.","Data flow diagram showing how providers enhance filter events with contextual blockchain data"]},{"l":"Basic Provider Usage","p":["Note that the ?. operator is used to safely access nested properties, preventing runtime errors if data is not available for any reason, e.g. if the account is not found, or if an API endpoint is temporarily down.","Important: Providers may trigger additional API calls to gather data not available from defined filters itself. This can impact performance when monitoring high-frequency events."]},{"i":"arrows_counterclockwise-filters-vs-providers","l":"\uD83D\uDD04 Filters vs. Providers","p":["Understanding the distinction between Filters and Providers is crucial for effective WorkerBee usage:"]},{"l":"Filters: The \"WHEN\" Layer","p":["Filters determine WHEN your callback should be triggered by monitoring specific blockchain events:","Monitor for specific events (posts, votes, transfers, etc.)","Trigger your callbacks when conditions are met","Work like event listeners - they detect what happened"]},{"l":"Providers: The \"WHAT\" Layer","p":["Providers determine WHAT additional data you need when filters trigger:","Fetch and structure additional contextual data","Provide rich, normalized information about accounts, blocks, prices, etc.","Work like data fetchers - they gather information you need to process the event","Execute automatically when any filter matches"]},{"l":"Working Together","p":["This separation allows for:","Clean architecture: Event detection separate from data fetching","Optimal performance: Providers only run when filters match","Flexible combinations: Mix any filters with any providers","Smart caching: Reuse provider data across multiple filter matches","For detailed filters information, check out the filters chapter:","Browse Detailed Filters Information"]},{"i":"gear-how-providers-work","l":"⚙️ How Providers Work"},{"l":"Provider Squashing & Optimization","p":["WorkerBee intelligently combines multiple calls to the same provider type, significantly optimizing performance. When you call the same provider multiple times, WorkerBee merges all parameters into a single efficient request.","This optimization works for every provider per type and dramatically reduces API calls and processing overhead."]},{"i":"arrows_counterclockwise-working-with-iterators","l":"\uD83D\uDD04 Working with Iterators","p":["Many providers return data as WorkerBee iterators for optimal performance and memory usage. These iterators are fully compatible with standard JavaScript iteration patterns.","Example providers that return WorkerBeeIterable:","Feed Price Provider: data.feedPrice.priceHistory- Historical price data","New Account Provider: data.newAccounts- Newly created accounts","Impacted Account Provider: data.impactedAccounts[account]- Operations affecting accounts","Whale Alert Provider: data.whaleOperations- Large transfers","Exchange Transfer Provider: data.exchangeTransferOperations- Exchange deposits/withdrawals","Internal Market Provider: data.internalMarketOperations- DEX operations","Alarm Provider: data.alarmsPerAccount[account]- Account security alerts"]},{"l":"For...of Loop (Recommended)"},{"l":"forEach Method"},{"l":"Working with Multiple Provider Iterators"},{"i":"link-providers-and-logical-filters-interaction","l":"\uD83D\uDD17 Providers and Logical Filters Interaction","p":["Important: Providers are independent of logical operators( and/ or) and can be placed anywhere in the filter chain. They will always execute when any filter matches, regardless of logical grouping.","This design ensures that providers deliver consistent, complete data regardless of which specific filter triggered the event."]},{"i":"rocket-advanced-example-mixed-providers--filters","l":"\uD83D\uDE80 Advanced Example: Mixed Providers & Filters","p":["Here's a sophisticated example demonstrating provider squashing, iterators, and complex filter combinations:","This example demonstrates:","Provider squashing: Multiple provideAccounts calls are automatically optimized","Iterator usage: Clean iteration over posts, comments, votes, and whale operations","Data correlation: Using account data alongside manabar information","Complex filtering: Multiple OR conditions with independent provider execution","Performance optimization: Parallel provider execution with intelligent caching"]},{"i":"books-complete-reference","l":"\uD83D\uDCDA Complete Reference","p":["For comprehensive examples of all available providers, check out the complete API reference:","Browse All Provider Examples in API Reference"]}],[{"l":"Common Patterns","p":["Learn proven patterns and best practices for building robust WorkerBee applications. These patterns solve common challenges and provide reusable solutions."]},{"l":"\uD83D\uDC65 Social & Content","p":["Brand monitoring","Community engagement alerts","Community member monitoring","Content creator activity dashboard","Customer service automation","Key Filters:","onComments()- Monitor comments and replies","onCommentsIncomingPayout()- Track comment payouts","onFollow()- Track follow/unfollow actions","onMention()- Detect @username mentions","onPosts()- Track new posts by specific authors","onPostsIncomingPayout()- Track post payouts","onReblog()- Monitor content resharing","onVotes()- Watch voting activity","Personal activity notifications","Use Cases:","User engagement analytics"]},{"l":"Content Creator Dashboard","p":["Comprehensive content creator monitoring that tracks all social activities."]},{"l":"Content Engagement Tracker","p":["Monitor brand mentions and content interactions for marketing purposes."]},{"l":"\uD83C\uDFE6 Financial Operations","p":["Use Cases:","Market movement tracking","Large transfer alerts","Investment monitoring","Risk management systems","Portfolio tracking","Trading bot integration","Key Filters:","onWhaleAlert()- Monitor large transfers above threshold","onAccountsBalanceChange()- Track balance changes","onExchangeTransfer()- Monitor exchange movements","onInternalMarketOperation()- Track market operations"]},{"l":"Market Movement Detector","p":["Monitor significant market movements and financial activities."]},{"l":"Investment Portfolio Monitor","p":["Monitor investment portfolios and account activities for financial tracking."]},{"l":"\uD83D\uDC64 Account Management","p":["Account activity aggregation","Account lifecycle tracking","Account recovery assistance","Delegation management","Key Filters:","Multi-account management dashboards","onAccountsBalanceChange()- Monitor account balance updates","onAccountsFullManabar()- Detect when accounts reach 98% manabar capacity","onAccountsManabarPercent()- Monitor manabar threshold percentages","onAccountsMetadataChange()- Track profile and metadata changes","onImpactedAccounts()- Monitor all operations affecting accounts","onNewAccount()- Monitor new account creation","Personal account monitoring","Profile change notifications","Resource efficiency optimization","Use Cases:"]},{"l":"Multi-Account Dashboard","p":["Comprehensive account management for monitoring multiple accounts across all activities."]},{"l":"Account Resource Optimizer","p":["Optimize manabar usage across accounts for maximum efficiency and prevent resource waste."]},{"l":"\uD83D\uDD10 Security & Governance","p":["Use Cases:","Account security monitoring","Recovery account tracking","Governance participation monitoring","Security audit logging","Resource optimization","Account efficiency tracking","Key Filters:","onAlarm()- Monitor security and governance events","onAccountsMetadataChange()- Track profile changes","onNewAccount()- Monitor new account creation","onAccountsFullManabar()- Detect full mana recovery","onAccountsManabarPercent()- Monitor mana thresholds"]},{"l":"Account Security Monitor","p":["Monitor account health indicators and security events."]},{"l":"Resource Management Bot","p":["Optimize engagement timing based on resource availability."]},{"l":"⚙️ Blockchain Infrastructure","p":["Block production analysis","Custom protocol tracking","dApp-specific monitoring","Infrastructure alerting","Key Filters:","Network performance monitoring","onBlock()- Monitor all new blocks","onBlockNumber()- Track specific block numbers","onCustomOperation()- Monitor custom JSON operations","onFeedPriceChange()- Monitor price feed updates","onFeedPriceNoChange()- Detect stale price feeds","onImpactedAccounts()- Monitor all affected accounts","onTransactionIds()- Track specific transactions","onWitnessesMissedBlocks()- Monitor witness performance","Use Cases:","Witness tracking"]},{"l":"Witness Performance Monitor","p":["Monitor witness performance and blockchain infrastructure health."]},{"l":"\uD83C\uDFAF Custom Filter & Provider Patterns","p":["Use Cases:","External API integration","Custom business logic","Multi-source data correlation","Complex conditional triggers"]},{"l":"External API Integration Pattern","p":["Combine blockchain events with external data sources leveraging filterPiped functionality:"]}],[{"l":"Past Data","p":["WorkerBee provides a rich set of historical data that can be leveraged for various use cases, such as analytics, reporting, and machine learning. This section outlines how to access and utilize past data effectively.","You can also feed the bot using past blockchain data, before running into live to collect data and/or analyze trends and patterns."]},{"l":"Overview: Live vs Past Data Modes","p":["WorkerBee offers two powerful ways to work with blockchain data, each designed for different use cases:"]},{"l":"Live Data Mode","p":["Monitor blockchain activity as it happens in real-time:","Purpose: Real-time monitoring and immediate responses","Data: Current blockchain state and live operations","Features: Full access to account information, witness data, and live calculations","Best for: Alerts, live dashboards, immediate notifications, trading bots"]},{"l":"Past Data Mode","p":["Analyze historical blockchain data for insights and patterns:","Purpose: Historical analysis and research","Data: Operations and blocks from specific time periods","Features: Efficient processing of large historical datasets","Best for: Analytics, pattern recognition, backtesting, research"]},{"l":"Past data setup"},{"l":"Specific block range setup","p":["When you know the exact block numbers you want to analyze, you can specify them directly. This method provides precise control over the data range and is ideal for:","Analyzing specific events: When you know a particular incident occurred between certain blocks","Reproducible analysis: Ensuring consistent results by using fixed block ranges","Performance optimization: Processing smaller, targeted datasets","Testing and debugging: Working with known data ranges during development","The method accepts two parameters:","startBlock(number): The first block to include in the analysis","endBlock(number): The last block to include in the analysis (inclusive)","Both block numbers must be valid blocks that exist on the Hive blockchain. The range is processed sequentially from startBlock to endBlock."]},{"l":"Relative timestamp setup","p":["-15m- last 15 minutes","-24h- last 24 hours","-30s- last 30 seconds","-7d- last 7 days","d- days","endBlock: Current head block (latest block on the chain)","Examples:","h- hours","Instead of specifying exact block numbers, you can use relative timestamps to define how far back in time you want to analyze data. The syntax uses a minus sign followed by a number and a time unit:","It is preferred to feed the bot with past data only once per WorkerBee instance!","m- minutes","s- seconds","startBlock: Calculated by subtracting the time period from the current block, using Hive's 3-second block production interval","Syntax: -{number}{unit}","Time units:","When using relative timestamps, WorkerBee automatically calculates the block range:"]},{"l":"Use Cases for Past Data"},{"l":"1. Pattern Analysis","p":["Analyze historical voting patterns, posting behavior, or market trends:"]},{"l":"2. Market Trend Analysis","p":["Study historical market movements and trading patterns:"]},{"l":"3. Community Growth Monitoring","p":["Track community development over time:"]},{"l":"4. Content Analytics","p":["Analyze posting patterns and engagement:"]},{"l":"Basic Past Data Usage"},{"l":"Simple Block Range Query"},{"l":"Relative Time Queries"},{"l":"Technical Architecture Differences"},{"l":"Data Collection Limitations","p":["Due to architectural differences between live and past data modes, certain types of data are not available in past data mode:"]},{"l":"Unavailable in Past Data Mode","p":["Account Data (provideAccounts)","Account information is not stored in block history","Alarm Events (onAlarm)","Alarms are time-based triggers, not historical data","Current account states may differ from historical states","Feed Price Data (provideFeedPriceData)","Feed prices are witness-provided data not stored in blocks","Manabar calculations require real-time RC and voting power","Manabar Data (onAccountsFullManabar, onAccountsBalanceChange)","Reason: Accounts change over time, block data only contains operations","Reason: Price feeds are published separately from block operations","Reason: These are calculated values, not stored in blockchain","Reason: Time-based events don't exist in past block data","Reason: Witness information changes dynamically","Witness Data (provideWitnesses, onWitnessesMissedBlocks)","Witness schedules and missed blocks require live monitoring"]},{"l":"Advanced Examples"},{"l":"Switching Between Past and Live Data","p":["You can seamlessly transition from historical analysis to live monitoring:"]},{"l":"Complex Historical Analysis"}],[{"l":"Core Architecture","p":["WorkerBee is built on a sophisticated multi-layered architecture that ensures high performance, reliability, and ease of use. Understanding this architecture helps you leverage WorkerBee's full potential."]},{"i":"mag-architectural-overview","l":"\uD83D\uDD0D Architectural Overview","p":["WorkerBee execution loop cycle"]},{"i":"robot_face-data-evaluation-context-dec","l":"\uD83E\uDD16 Data Evaluation Context (DEC)","p":["The Data Evaluation Context is WorkerBee's central nervous system. It orchestrates all data flow and provides:"]},{"l":"Dependency Injection","p":["The DEC automatically resolves dependencies between collectors, ensuring the right data sources are available when needed:"]},{"l":"Smart Caching System","p":["Within each evaluation cycle, the DEC maintains a shared cache that dramatically reduces API calls:"]},{"l":"Cycle Management","p":["The DEC manages evaluation cycles intelligently:","Historical Mode: Fast processing of past blocks","Live Mode: Time-based cycles (default: 2 seconds)"]},{"i":"mag_right-filters-layer","l":"\uD83D\uDD0E Filters Layer","p":["Filters evaluate blockchain conditions and determine when your observers should be triggered."]},{"l":"Parallel Execution","p":["All filters run concurrently for maximum performance:"]},{"l":"Short Circuit Evaluation","p":["When any filter matches, WorkerBee uses short-circuit evaluation to stop unnecessary processing:"]},{"i":"truck-providers-layer","l":"\uD83D\uDE9A Providers Layer","p":["Providers gather and transform data for your observers, running only when filters pass."]},{"l":"Data Transformation","p":["Providers normalize raw blockchain data into WorkerBee's clean API:"]},{"l":"Concurrent Processing","p":["Like filters, providers run in parallel:"]},{"i":"shopping_trolley-collectors-layer","l":"\uD83D\uDED2 Collectors Layer","p":["Collectors are the data acquisition layer, responsible for fetching information from various sources."]},{"l":"Dependency Resolution","p":["Collectors can depend on each other, and the DEC resolves these dependencies automatically:"]},{"l":"Overriding Collectors","p":["One of WorkerBee's powerful features is the ability to override multiple collectors using only one collector when it can retrieve all necessary data e.g. from a single API call. This happens automatically via the DEC.","The best example is the HistoryDataFactory, which uses only one API call to fetch all required data for historical analysis of block headers, block content and dynamic global properties state."]},{"i":"arrows_clockwise-data-flow-example","l":"\uD83D\uDD03 Data Flow Example","p":["Let's trace a complete data flow for this observer:"]},{"l":"Step-by-Step Flow","p":["DEC Initialization\uD83E\uDDE0","Analyzes required filters: PostFilter","Analyzes required providers: AccountProvider","Injects collectors: OperationCollector, AccountCollector, BlockCollector","Data Collection\uD83D\uDED2","Filter Evaluation\uD83D\uDD0E","Provider Execution\uD83D\uDE9A","Observer Callback\uD83E\uDD33"]},{"l":"\uD83D\uDEE0️ Custom Filters & Providers Architecture","p":["WorkerBee supports custom filters and providers for extending functionality beyond built-in capabilities."]},{"l":"Custom Filter Architecture","p":["Custom filters integrate seamlessly with the DEC system:","Architecture Benefits:","DEC Integration: Full access to cached collectors","Performance: Reuses existing data rather than re-fetching","Flexibility: Implement any custom logic","Type Safety: TypeScript support throughout"]},{"l":"Custom Provider Architecture","p":["Custom providers follow the same pattern as built-in providers:"]},{"l":"Store-Based Data Sharing","p":["Use the DEC store to share data between custom components:"]},{"l":"Filter Piped Architecture","p":["If you want to simultaneously use filters and providers accessing the same data via DEC store, it is easier to use filters with piped provider data system.","The filterPiped method creates a provider-filter chain where the provider runs first:","Execution Flow:","Provider Phase: Fetches external data","Filter Phase: Evaluates condition using provider data","Data Assembly: Provider data becomes part of notification","Notification: Both blockchain and external data available"]},{"i":"chart_with_upwards_trend-performance-optimizations","l":"\uD83D\uDCC8 Performance Optimizations"},{"l":"Caching Strategy","p":["Per-Cycle Caching: Data is cached only within each evaluation cycle","Atomic Snapshots: All components see consistent blockchain state","Memory Efficient: Cache is cleared between cycles"]},{"l":"Concurrency Benefits","p":["Filter Parallelism: All conditions evaluated simultaneously","Provider Parallelism: Data transformation happens concurrently","Short-Circuit Logic: Unnecessary work is cancelled early"]},{"l":"Smart Resource Management","p":["-0.7x","–","*- A Number of calls calculated based on the scenario of operation filter, 3 accounts filter and operation & account provider","+2×","10","250ms","3","500ms","6","830ms","API Call Reduction: Up to 50% fewer API calls in complex scenarios:","API Calls per cycle *","Dependency Optimization: Shared dependencies are resolved once","High","Low","Naive implementation","Network Latency","Node Load","On-Demand Collection: Data is only fetched when actually needed","Throughput","Very High","WorkerBee with DEC Cache","WorkerBee without DEC Cache"]},{"i":"bulb-architecture-benefits","l":"\uD83D\uDCA1 Architecture Benefits"},{"l":"Separation of Concerns","p":["Each layer has a single responsibility, making the system maintainable and testable."]},{"l":"Loose Coupling","p":["Components communicate through well-defined interfaces, allowing easy substitution."]},{"l":"High Performance","p":["Concurrent execution and intelligent caching provide optimal performance."]},{"l":"Flexibility","p":["The layered architecture supports multiple data sources and custom extensions."]},{"l":"Testability","p":["Each component can be tested in isolation with dependency injection.","This architecture ensures that WorkerBee can scale from simple use cases to complex enterprise applications while maintaining excellent performance and developer experience."]},{"i":"factory-collector-factories","l":"\uD83C\uDFED Collector Factories","p":["WorkerBee uses different factory patterns for live and past data. The mediator automatically switches between these factories without user interaction, preserving the internal application state. This seamless transition is possible thanks to the factories' extend functionality - each factory can extend itself with state from other factories."]},{"l":"JsonRpcFactory (Live Data)","p":["The JsonRpcFactory provides a comprehensive set of collectors for real-time data:","AccountCollector: Real-time account information","FeedPriceCollector: Current feed price data","WitnessCollector: Witness information and schedules","RcAccountCollector: Resource Credit account data","ManabarCollector: Live manabar calculations"]},{"l":"HistoryDataFactory (Past Data)","p":["The HistoryDataFactory uses a more limited set optimized for historical analysis:","BlockCollector: Historical block data via get_block_range","DynamicGlobalPropertiesCollector: Chain state at specific points","ImpactedAccountCollector: Accounts affected by operations","OperationCollector: Historical operations from blocks"]},{"l":"Factory Switching","p":["The automatic factory switching allows you to seamlessly transition from historical analysis to live monitoring:"]}],[{"l":"Advanced Examples","p":["Explore sophisticated use cases and patterns with WorkerBee. These examples demonstrate real-world applications and advanced techniques.","Some examples use the dotenv package to read from a .env file.","Create a .env file in your project root with the specified by each example environment variables.","If you are working with TypeScript, ensure you have the necessary type definitions installed:"]},{"i":"robot_face-nodejs-intelligent-voting-bot","l":"\uD83E\uDD16 Node.js Intelligent Voting Bot","p":["A smart voting bot that considers multiple factors before casting votes.","POSTING_WIF_KEY- Posting private key for your Hive account.","HIVE_ACCOUNT- Your Hive account name used for voting."]},{"i":"closed_lock_with_key-telegram-authorization-bot","l":"\uD83D\uDD10 Telegram Authorization Bot","p":["A bot that proofs user Hive account ownership via Telegram. No more guessing usernames!","BOT_TOKEN- Telegram bot token from BotFather","BRIDGE_URL- URL of your Hive dAppAuth bridge instance. This would be usually https://auth.openhive.network or similar.","HIVE_ACCOUNT- Your Hive account name used as a dApp identifier in the dAppAuth operations. This wil be displayed to users when they authorize."]},{"l":"Authorization flow","p":["Telegram Bot Message","Authorization window"]},{"i":"bell-rss-advanced-notification-system","l":"\uD83D\uDD14 RSS Advanced Notification System","p":["A comprehensive notification system for RSS feeds regarding critical account updates.","For testing, you can use any RSS reader app or website. Some popular options include:","Feedly","Inoreader","RSS Feed Reader Chrome Extension","express- Web server to serve the RSS feed.","cors- Middleware to enable CORS for the RSS feed - may be required by some clients.","@types/express, @types/cors- TypeScript-only types for the above packages."]},{"l":"RSS Feed Example","p":["Raw RSS Feed Data","RSS Feed in Reader"]},{"i":"mag_right-ai-powered-content-quality-analyzer","l":"\uD83D\uDD0E AI-powered Content Quality Analyzer","p":["Analyze and score content quality using various metrics.","OPENAI_API_KEY- Your OpenAI API key from OpenAI","openai- Official OpenAI SDK for API access."]},{"l":"Example Output","p":["Example AI analysis console output"]},{"i":"trophy-rest-api-achievement-system","l":"\uD83C\uDFC6 REST API Achievement System","p":["Gamify user engagement with an achievement system.","This example also leverages the power of WorkerBee to analyze past operations and maintain a local state.","express- Web server to serve the REST API.","cors- Middleware to enable CORS for the API - may be required by some clients.","@types/express, @types/cors- TypeScript-only types for the above packages."]},{"l":"Example API Output","p":["curl -s http://localhost:3000/achievements/scifimultiverse | jq"]},{"i":"love_letter-summary","l":"\uD83D\uDC8C Summary","p":["These advanced examples showcase WorkerBee's power for building sophisticated blockchain applications. Each example demonstrates different architectural patterns, real-world use cases, and advanced features of the library."]}],[{"l":"API Reference","p":["For a complete TypeScript API reference for WorkerBee you can visit WorkerBee Wiki.","This document covers all filters & providers, divided into categories, available in the library."]},{"l":"Filters","p":["Data Mode Availability:","\uD83D\uDFE2 Live Mode Only- These filters require real-time blockchain data and are only available when using workerbee.observe","\uD83D\uDD35 Live and Past Data Modes- These filters work with both live data ( workerbee.observe) and historical data ( workerbee.providePastOperations())"]},{"l":"\uD83D\uDC64 Tracking Account Activity"},{"l":"onAccountsFullManabar","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter triggers when any of the specified accounts reaches 98% manabar capacity. The monitored manabar type is specified as the first parameter and can be one of 3 types: UPVOTE, DOWNVOTE, or RC. The filter provides manabar information for each monitored account in the callback data. When observing multiple accounts, remember to check if manabar data is available for the specific account."]},{"l":"onAccountsManabarPercent","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter works similarly to onAccountsFullManabar, but allows you to specify a custom manabar percentage threshold. It provides the account's manabar data in the callback."]},{"l":"onAccountsMetadataChange","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter triggers when any of the specified accounts updates their metadata. You can observe multiple accounts in a single observer call. This filter provides the account data in the callback when metadata changes occur."]},{"l":"onImpactedAccounts","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when any new blockchain operation affects one of the specified accounts (transfers, votes, mentions, etc.), also when the account is just referenced by operation that has been authorized by another account, i.e. when alice voted on bob's comment, bob is also and impacted account. You can monitor multiple accounts in both live and past data modes. Remember to check if data for a specific account actually exists when observing multiple accounts."]},{"l":"onNewAccount","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when new accounts are created on the blockchain through account creation operations. It monitors three types of account creation operations: account_create_operation, account_create_with_delegation_operation, and create_claimed_account_operation. The filter requires no input parameters as it monitors all new account creations globally. The callback data includes detailed information about each newly created account, including the account name, creator, authorities, and metadata."]},{"l":"⚙️ Blockchain Infrastructure"},{"l":"onBlockNumber","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when the blockchain reaches a specific block number. It is useful for scheduled operations, testing scenarios, or waiting for governance proposals that become active at a particular block. The filter takes a single block number parameter and monitors the blockchain until that exact block is produced. The filter provides no callback data as it is designed to be a simple notification mechanism - if you need block details, combine it with block providers."]},{"l":"onBlock","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers on every new block produced on the blockchain. Unlike onBlockNumber which waits for a specific block number to be reached and then triggers once, onBlock continuously monitors the blockchain and triggers for every single block that gets produced. It provides comprehensive block header data in the callback, making it perfect for real-time blockchain monitoring and applications that need to process every block. The filter requires no input parameters. When processing past data, it will trigger for each block in the specified range, allowing you to replay blockchain history."]},{"l":"onTransactionIds","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when specific transaction IDs appear on the blocks distributed by blockchain. It is particularly useful for tracking the inclusion of specific transactions in blocks, monitoring transaction confirmations, or building applications that need to react when certain transactions are processed. You can monitor multiple transaction IDs simultaneously, and the filter will trigger when any of them appears on the blockchain. The callback provides detailed transaction data for each monitored transaction ID, allowing you to access the full transaction content and metadata."]},{"l":"\uD83C\uDFE6 Financial Operations"},{"l":"onAccountsBalanceChange","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter triggers when account balances change due to various financial operations on the blockchain. It monitors all types of balance changes including incoming and outgoing transfers, author/curation rewards, witness rewards, power ups/downs, savings operations, and conversions. The filter allows you to specify whether to include internal balance changes through the includeInternal parameter. You can monitor multiple accounts simultaneously, making it perfect for portfolio tracking, payment processing, or automated financial applications. This filter provides the account data in the callback when balance changes occur."]},{"l":"onExchangeTransfer","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when transfers involve known cryptocurrency exchange accounts on the Hive blockchain. WorkerBee maintains an internal list of recognized exchange accounts and automatically monitors all transfer operations that either originate from or are directed to these exchanges. This is particularly useful for tracking market movements, analyzing trading patterns, detecting large deposits/withdrawals, or building exchange monitoring applications. The filter requires no input parameters as it globally monitors all exchange-related transfers, making it ideal for market analysis and trading bot applications. It provides detailed transfer data including amounts, sender/receiver information, and memo fields, allowing you to analyze exchange activity patterns."]},{"l":"onFeedPriceChange","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter triggers when the Hive price feed changes by a specified percentage threshold. It monitors the official price feed data published by witnesses and detects significant price movements that exceed your defined percentage threshold. This is particularly useful for building trading bots, price alert systems, or applications that need to react to market volatility. The filter allows you to set a custom percentage threshold (e.g., 5 for 5% change) to control the sensitivity of price change detection. It's perfect for monitoring market conditions without constantly polling price data. The filter is essential for financial applications that need to respond to significant price movements on the Hive blockchain."]},{"l":"onFeedPriceNoChange","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter triggers when the Hive price feed remains completely unchanged for a specified number of hours. Unlike onFeedPriceChange which detects price movements, this filter is designed to detect periods of price stability and low market volatility. The filter monitors the price history feed data and checks if the exact same price value has been maintained for the specified duration. This is particularly useful for detecting market stagnation, low trading volume periods, or identifying optimal times for certain trading strategies that work best in stable market conditions. The filter accepts a parameter specifying the number of hours of required stability, with a default of 24 hours if no parameter is provided."]},{"l":"onInternalMarketOperation","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when operations occur on Hive's built-in internal decentralized exchange (DEX) for HIVE ↔ HBD trading. It monitors three specific types of market operations: limit order creation, order cancellation, and automatic order fills when orders are matched. The internal market allows users to trade between HIVE and HBD (Hive Backed Dollars) directly on the blockchain without using external exchanges. This filter is particularly useful for building market analysis tools, arbitrage bots, trading dashboards, or applications that need to track decentralized trading activity. The filter requires no input parameters as it globally monitors all internal market operations, providing comprehensive coverage of the built-in DEX activity."]},{"l":"onWhaleAlert","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when large transfers exceed a specified amount threshold, making it perfect for monitoring significant financial movements on the Hive blockchain. It monitors four specific types of transfer operations: regular transfers, transfers from savings, escrow transfers, and recurrent transfers. The filter is commonly known as \"whale watching\" in crypto communities, as it helps detect when large holders (whales) move substantial amounts of cryptocurrency. You can specify any asset type and amount threshold using the chain's helper methods like bot.chain.hiveCoins(1000). This filter is particularly useful for market analysis, detecting potential market-moving transactions, building trading alerts, or monitoring large account movements for security purposes."]},{"l":"\uD83D\uDD10 Security & Governance"},{"l":"onAlarm","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter triggers when monitored accounts experience security or governance-related situations that require attention."]},{"l":"Supported Alarm Types","p":["Accounts still using \"steem\" as recovery account from the old blockchain","Accounts that have declined their voting rights","Accounts that haven't participated in governance for extended periods","Active recovery account changes during the 30-day waiting period","Allows proactive governance participation management","Critical security event requiring monitoring","Declining Voting Rights (DECLINING_VOTING_RIGHTS)","Governance Vote Expiration Soon (GOVERNANCE_VOTE_EXPIRATION_SOON)","Governance Vote Expired (GOVERNANCE_VOTE_EXPIRED)","Governance votes expiring within one month","Important for tracking account voting status changes","Indicates accounts with expired or missing governance votes","Indicates outdated security configuration that should be updated","Legacy Recovery Account Configuration (LEGACY_RECOVERY_ACCOUNT_SET)","Recovery Account Change in Progress (RECOVERY_ACCOUNT_IS_CHANGING)","The filter is essential for account security monitoring, governance participation tracking, and detecting potentially compromised or misconfigured accounts. You can monitor multiple accounts simultaneously, making it perfect for wallet applications, account management tools, or security monitoring systems.","The onAlarm filter detects the following five specific alarm types:"]},{"l":"onWitnessesMissedBlocks","p":["\uD83D\uDFE2 Live Mode Only- This filter requires real-time blockchain data and is not available in past data mode.","This filter triggers when specified witness accounts miss a threshold number of consecutive blocks during their scheduled block production turns. It monitors witness performance by tracking the totalMissedBlocks counter and lastConfirmedBlockNum to detect when witnesses fail to produce blocks when they're supposed to. The filter is essential for network health monitoring, witness performance analysis, and detecting potential issues with witness nodes (server downtime, connectivity problems, or configuration issues). It intelligently resets its tracking when a witness successfully produces a block again, preventing duplicate notifications for the same missed block streak. You can monitor multiple witnesses simultaneously with different threshold values, making it perfect for witness monitoring dashboards, alerting systems, or blockchain infrastructure monitoring tools."]},{"l":"\uD83D\uDC65 Social & Content"},{"l":"onCommentsIncomingPayout","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when replies/comments(not top-level posts) by specified authors are approaching their payout window expiration, allowing you to monitor engagement performance before final reward distribution. On the Hive blockchain, comments have a 7-day payout window after creation, and this filter detects when they're nearing that critical payout moment. The filter specifically monitors replies to posts or other comments (content with a non-empty parent_author field), distinguishing them from top-level posts. You can specify a relative time offset (like \"-30m\" for 30 minutes before payout or \"-1h\" for 1 hour before) to receive notifications at your preferred timing. This is particularly useful for content creators, curators, or applications that need to take action before payout finalization - such as last-minute promotion, vote adjustments, or performance analytics. You can monitor multiple authors simultaneously, making it perfect for content management dashboards, curation tools, or automated content promotion systems. Remember that you need to collect past operations to access old posts and comments to monitor their payout right after starting the application.","Note: For monitoring top-level posts approaching payout, use onPostsIncomingPayout instead."]},{"l":"onComments","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when specified authors create new comments on the Hive blockchain. Top level posts are ignored by this filter. Comments are replies to posts or other comments, distinguished from posts by having a non-empty parent_author field in the underlying comment_operation. The filter monitors all comment creation activity and provides detailed comment data in the callback, including operation details like author, permlink, parent information, and content metadata. You can monitor multiple authors simultaneously, making it perfect for content moderation tools, engagement tracking systems, discussion monitoring applications, or building comment notification services. It's particularly useful for building social media applications, content curation tools, or automated response systems that need to react to new comment activity."]},{"l":"onCustomOperation","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when custom JSON operations with specified operation IDs appear on the Hive blockchain. Custom operations are the primary mechanism for decentralized applications (dApps), games, and services to extend Hive's functionality with their own custom logic and data structures. The filter monitors both custom_json_operation and custom_operation types, allowing you to track specific application protocols by their unique identifiers. Popular examples include gaming operations like Splinterlands rewards (\"sm_claim_reward\"), community actions (\"community\"), or any other dApp-specific functionality. You can monitor multiple operation IDs simultaneously, making it perfect for building application-specific monitoring tools, analytics dashboards, bot automation systems, or cross-platform dApp integration services. It's essential for developers building on Hive who need to track their own custom operations or monitor activity from other applications in the ecosystem.","Note: For social interactions like \"follow\" and \"reblog\", use the specialized onFollow and onReblog filters instead, which provide more targeted functionality and enhanced data."]},{"l":"onFollow","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when specified accounts perform social relationship operations on the Hive blockchain, including following, unfollowing, muting, and blacklisting other accounts. The filter monitors custom JSON operations with the \"follow\" ID, which contain the social graph interaction data that powers Hive's decentralized social networking features. It tracks various relationship types through the what field in the operation, supporting actions like \"blog\" (follow), \"mute\", \"blacklist\", and their corresponding removal operations. These operations are fundamental to Hive's social layer, allowing users to build their feeds, manage unwanted content, and create curated social experiences. You can monitor multiple accounts simultaneously, making it perfect for building social analytics tools, relationship tracking dashboards, follower notification systems, or automated social interaction bots. It's essential for applications that need to track social dynamics, build recommendation systems, or provide users with insights about their social network activity."]},{"l":"onMention","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when specified accounts are mentioned in posts or comments using the standard @username syntax on the Hive blockchain. The filter scans the text content of all posts and comments to detect username mentions and match them against your monitored account list. It processes both new posts (top-level content) and comments (replies), providing comprehensive mention detection across all content types on the platform. The filter is essential for building notification systems, social engagement tools, and automated response applications that need to react when specific users are mentioned in discussions. You can monitor multiple accounts simultaneously, making it perfect for community management tools, brand monitoring applications, or personal notification services. It's particularly valuable for social media managers, content creators, and businesses who need to stay informed about when their accounts or brands are being discussed in the Hive community."]},{"l":"onPostsIncomingPayout","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when top-level posts(not replies/comments) by specified authors are approaching their payout window expiration, allowing you to monitor content performance before final reward distribution. On the Hive blockchain, posts have a 7-day payout window after creation, and this filter detects when they're nearing that critical payout moment. The filter specifically monitors top-level posts (content with an empty parent_author field), distinguishing them from replies and comments. You can specify a relative time offset (like \"-30m\" for 30 minutes before payout or \"-1h\" for 1 hour before) to receive notifications at your preferred timing. This is particularly useful for content creators, curators, or applications that need to take action before payout finalization - such as last-minute promotion, vote adjustments, or performance analytics. You can monitor multiple authors simultaneously, making it perfect for content management dashboards, curation tools, or automated content promotion systems. Remember that you need to collect past operations to access old posts and comments to monitor their payout right after starting the application.","Note: For monitoring replies/comments approaching payout, use onCommentsIncomingPayout instead."]},{"l":"onPosts","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when specified authors create new posts on the Hive blockchain. Replies (comments) to posts are ignored by this filter. Posts are top-level content pieces, distinguished from comments by having an empty parent_author field in the underlying comment_operation. The filter monitors all post creation activity and provides detailed post data in the callback, including operation details like author, permlink, title, body, and content metadata. You can monitor multiple authors simultaneously, making it perfect for content aggregation platforms, feed generation systems, blog monitoring applications, or building post notification services. It's particularly useful for building social media applications, content curation tools, or automated promotion systems that need to react to new post publications."]},{"l":"onReblog","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter triggers when specified accounts reblog (share/repost) content on the Hive blockchain. Reblogs are a social sharing mechanism that allows users to reshare posts from other authors to their own feed, helping content reach a wider audience through the social network. The filter monitors custom JSON operations with the \"follow\" ID that contain reblog actions, tracking when users share content they find valuable or interesting. Reblogging is fundamental to content discovery and viral spread on Hive, allowing quality content to gain visibility beyond the original author's followers. You can monitor multiple accounts simultaneously, making it perfect for building content distribution analytics, engagement tracking systems, influencer monitoring tools, or automated content promotion platforms. The filter works with both live and past data modes, enabling real-time reblog monitoring and historical analysis of content sharing patterns. It's particularly useful for understanding content virality, measuring influence networks, tracking brand mentions through shares, or building recommendation systems based on social sharing behavior."]},{"l":"onVotes","p":["\uD83D\uDD35 Live and Past Data Modes- This filter is available in both live and past data modes.","This filter monitors voting activity on the Hive blockchain, triggering when specified accounts cast votes on posts or comments. It tracks both upvotes and downvotes, providing complete voting operation details including vote weights, target content, and transaction information. The filter supports monitoring multiple voters simultaneously and provides voting data organized by voter account.","The filter captures all vote operations including upvotes, downvotes, and vote deletions (zero weight votes). Each vote operation contains information about the voter, target author/permlink, vote weight, and associated blockchain transaction. This enables comprehensive tracking of content curation activities, voting patterns, and community engagement behaviors.","Key capabilities include:","Real-time vote monitoring: Tracks voting activity as it happens on the blockchain","Multi-voter support: Monitor voting activity from multiple accounts in a single observer","Complete vote data: Access to vote weight, target content, voter information, and transaction details","It's particularly useful for building content curation dashboards, vote tracking systems, community engagement analytics, and voting behavior analysis tools."]},{"l":"Providers","p":["Data Mode Availability:","\uD83D\uDFE2 Live Mode Only- These providers require real-time blockchain data and are only available when using workerbee.observe","\uD83D\uDD35 Live and Past Data Modes- These providers work with both live data ( workerbee.observe) and historical data ( workerbee.providePastOperations())","Providers are specialized data suppliers that enhance WorkerBee filters by delivering enriched blockchain data directly to your observer callbacks. While filters detect specific events or conditions on the blockchain, providers add contextual data and detailed information about accounts, transactions, blocks, and other blockchain entities.","Providers automatically integrate with filters and deliver their data through the same subscription callback, eliminating the need for separate API calls. This creates a seamless development experience where you can access both event notifications and related data in a single observer. They also are able to reuse already acquired data by filters if possible and avoid additional queries. What's important to note, they start to work only when filter condition matches."]},{"l":"\uD83D\uDC64 Account Data Providers"},{"l":"provideAccounts","p":["\uD83D\uDFE2 Live Mode Only- This provider requires real-time blockchain data and is not available in past data mode.","This provider extends the data passed to specified callback function by comprehensive account information for specified accounts. It retrieves detailed account data including balances, voting power, profile metadata, and recovery account. The provider automatically fetches current account state data and delivers it alongside your filter results. You can specify multiple accounts to monitor simultaneously, making it perfect for portfolio tracking, account management applications, or social media dashboards. The provider is essential for applications that need detailed user information, wallet interfaces, or account analysis tools."]},{"l":"provideManabarData","p":["\uD83D\uDFE2 Live Mode Only- This provider requires real-time blockchain data and is not available in past data mode.","This provider delivers detailed manabar information for specified accounts and manabar types. It provides real-time data about account resource usage including current mana levels, last update time, and percentage capacity. The provider supports all three manabar types: upvote, downvote, and resource credits (RC). Manabar data is crucial for applications that need to manage account resources efficiently or provide users with resource usage insights. You can monitor multiple accounts simultaneously, making it perfect for account management tools, automated posting applications, or resource optimization systems."]},{"l":"provideRcAccounts","p":["\uD83D\uDFE2 Live Mode Only- This provider requires real-time blockchain data and is not available in past data mode.","This provider supplies comprehensive resource credit (RC) account information for specified accounts. It delivers detailed RC system data including current RC balance, maximum capacity, and last update time. The provider gives access to advanced RC metrics that are essential for applications managing blockchain resource consumption. Resource credits are fundamental to Hive's bandwidth system, determining how many operations accounts can perform without fees. You can monitor multiple accounts simultaneously, making it perfect for account management tools, resource optimization applications, or automated systems that need to track RC usage."]},{"l":"provideWitnesses","p":["\uD83D\uDFE2 Live Mode Only- This provider requires real-time blockchain data and is not available in past data mode.","This provider delivers comprehensive witness information for specified witness accounts. It provides detailed witness data including owner, version and block production performance. The provider gives access to witness performance metrics, like missed block counts that are essential for monitoring network infrastructure. Witnesses are the block producers on the Hive blockchain, and their performance directly affects network security and stability. You can monitor multiple witnesses simultaneously, making it perfect for witness monitoring dashboards, network health analysis tools, or voting decision applications."]},{"l":"⚙️ Blockchain Data Providers"},{"l":"provideBlockData","p":["\uD83D\uDD35 Live and Past Data Modes- This provider is available in both live and past data modes.","This provider delivers comprehensive block information including both block header (already collected by onBlock filter) and full block data (like all included transactions). It provides detailed block content including all transactions, operations, witness signatures, and block metadata. The provider combines block header data (block number, timestamp, witness) with complete block content for comprehensive blockchain monitoring. Block data is fundamental for applications that need to process all blockchain activity or analyze transaction patterns. The provider automatically delivers block information with your filter results, eliminating the need for separate block API calls."]},{"l":"provideBlockHeaderData","p":["\uD83D\uDD35 Live and Past Data Modes- This provider is available in both live and past data modes.","This provider supplies essential block header information including block number, timestamp, witness, and basic block metadata. It provides lightweight block data that is perfect for applications that need block timing and identification information without the overhead of full block content. Block header data includes critical blockchain timing information and witness rotation details that are essential for many blockchain applications. The provider delivers header information efficiently, making it ideal for high-frequency monitoring applications or resource-constrained environments. It automatically integrates with your filters, providing block context alongside event notifications."]},{"l":"\uD83C\uDFE6 Financial Data Providers"},{"l":"provideFeedPriceData","p":["\uD83D\uDFE2 Live Mode Only- This provider requires real-time blockchain data and is not available in past data mode.","This provider delivers comprehensive HIVE price feed information including current prices, price history, and statistical price data. It provides access to the official witness-published price feeds that determine HIVE-to-HBD conversion rates on the blockchain. The provider supplies current median, minimum, and maximum price values along with historical price data for trend analysis. Price feed data is essential for financial applications, trading bots, conversion calculators, and economic analysis tools. The provider delivers real-time price information alongside your filter results, enabling applications to react to both events and current market conditions."]},{"l":"\uD83D\uDEE0️ Custom Filters & Providers"},{"l":"filter","p":["\uD83D\uDD35 Live and Past Data Modes- Custom filters work with both live and historical data.","This powerful method allows you to create custom filters that aren't provided by WorkerBee out of the box. You can create complex conditions using external APIs, database queries, or any custom logic. Custom filters have access to the Data Evaluation Context (DEC), enabling them to use cached data from WorkerBee's collectors for optimal performance."]},{"l":"provide","p":["\uD83D\uDD35 Live and Past Data Modes- Custom providers work with both live and historical data.","Create custom data providers to extend WorkerBee's functionality with your own data sources. Custom providers can access the DEC to use cached blockchain data and add their own computed results to the notification data."]},{"l":"filterPiped","p":["\uD83D\uDD35 Live and Past Data Modes- Filter piped functionality works with both live and historical data.","This advanced method creates a filter that uses data provided by a custom provider in the same evaluation chain. The provider is guaranteed to run before the filter, enabling complex conditional logic based on external data sources. The piped data becomes part of the final notification data."]}],[{"l":"Thank You for Exploring WorkerBee","p":["We hope this documentation has been helpful in your journey with the WorkerBee library for Hive blockchain development. Your feedback and contributions are valuable to us!"]},{"l":"Stay Connected","p":["\uD83D\uDCAC Developer Chat: Join us on openhive.chat using your Hive account (Recommended)","\uD83D\uDCF1 Community: Connect with the broader Hive community on Telegram(Please avoid sharing sensitive information)","\uD83D\uDC1E Report Issues: Submit bugs or feature requests on WorkerBee GitLab"]},{"l":"Additional Resources","p":["\uD83D\uDCDA Hive Developer Portal- Official developer resources for the Hive ecosystem","\uD83C\uDF10 Hive Block Explorer- Explore Hive transactions and accounts","\uD83D\uDD0D API Documentation- Swagger reference for the Hive REST API endpoints","\uD83E\uDDEA Transaction Inspector- Analyze and debug your Hive transactions"]},{"l":"Contributing","p":["We welcome contributions to both this documentation and the WorkerBee library.","Thank you for being part of our community! Happy coding! \uD83D\uDE80"]}]]