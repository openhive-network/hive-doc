[[{"l":"Intro to Wax library","p":["Wax is a multi-language, object-oriented library for interacting with the Hive blockchain network. There are currently three language implementations of the library: TypeScript, C++, and Python. Each implementation of Wax incorporates the same code used by the core Hive protocol library to define Hive objects (operations, transactions, etc). This ensures that Wax will always maintain compatibility with the core blockchain protocol.","Wax enables developers to:","read blockchain data from Hive API endpoints by making API requests","write new blockchain data by creating and broadcasting Hive transactions containing various blockchain operations to Hive API endpoints","This document contains executable examples that readers can directly interact with. When first opened, an example will automatically execute. You can also modify an example and re-run it. To re-run an example after modifying it, press the up-arrow in the terminal window to fetch the last command in the command line history (this is the command used to originally execute the example).","Start by exploring the Wax Getting Started Guide:","Getting Started"]}],[{"l":"Getting Started","p":["Wax enables developers to read and write data on the Hive blockchain. This guide will help you get started with the Wax library."]},{"l":"Installing","p":["First step is to install the library. Choose the appropriate installation command for your programming language.","View WAX package on npmjs \uD83E\uDC6D","You can also use other package managers, such as: npm or yarn","TBA"]},{"l":"Implementation details","p":["Base interface(no endpoint required) VS Chain interface(requires an endpoint)"]},{"l":"Root Interface Design Theory","p":["Allows pushing operations into transactions, validating, signing, and building transactions.","Asset Handling:","Can securely suggest brain keys and derive private keys from seeds.","Conversion between different transaction and protocol formats.","Create transaction from JSON- taking a transaction in the Hive-API JSON form","Create transaction from Proto- taking a transaction in the protobuf form","Create transaction with TaPoS- taking the taposBlockId and optionaly the expiration time.","Encryption and Decryption:","Methods for handling HIVE, HBD, and VESTS in their native asset forms ( NAI).","Methods for working with manabar values, which relate to the user's resource credits and voting power.","Methods to convert these assets and calculate values, such as HBD to HIVE, HIVE to HBD, HIVE to VESTS, and VESTS to HP.","Miscellaneous Utilities:","Provides 3 methods for creating transactions. Each of them returns ITransaction type, the difference is only in parameters that each of those methods take:","Provides methods for encrypting and decrypting data using keys stored in a wallet.","The Base interface is a low-level interface that deals with basic functionalities that don't require communication with an API endpoint. About the only reason to directly use this interface is for creating an offline transaction signer, and even then the transactions first need to be constructed using an online application because valid hive transactions require current blockchain data. Here's a breakdown of what it includes:","Transaction Building:"]},{"l":"Hive Chain Interface","p":["The Chain interface extends the functionalities of the Base interface and adds high-level network-related operations. This interface connects to a Hive API endpoint. Here are some highlights:","Network Operations:","Creating transaction with Automatic Data Fetching: It can fetch the head block or reference block data automatically, which is crucial for building and broadcasting transactions.","Provides high-level methods which do not require the user to manually specify block IDs or other network data-related details.","API Endpoint Management:","Allows specifying and querying the API with custom endpoint URL - global, per-API-category or per-request.","Provides access to multiple pre-configured standard Hive RPC APIs ( account_by_key_api, block_api, database_api, network_broadcast_api, rc_api).","Extended API Capability:","Supports extending the core API with custom APIs through the extend and extend REST method, enabling custom RPC/REST calls with a full IntelliSense support.","Enhanced Manabar Calculation:","Multiple methods (including manabar-related calculations) which fetch and calculate real-time blockchain account states directly from the network."]}],[{"l":"Constructing a Wax interface","p":["The root Wax interface can be constructed using either default or custom configuration options. Custom options allow selecting a specific blockchain network (e.g. mainnet, testnet, or mirrornet), a specific Hive API endpoint (e.g. api.hive.blog) and also a custom REST API endpoint. It also provides settings to optimize for performance, network latency, or other custom needs."]},{"l":"Default Wax initialization"},{"l":"Initializing Wax interface with custom options"}],[{"l":"Generating private keys","p":["Hive layer 1 keys can be generated via two methods:","Derivation of a set of private keys from a password (sometimes referred to as a \"Master Password\"). This is typically used to initially create active, owner, posting, and memo keys for a Hive account.","Randomly generate a new private key (generally should only be used in one-time-use scenarios)."]},{"l":"Generate a private key for an account role from a password","p":["The master password should always be a truly random and secure value","Output"]},{"l":"Suggest Brain Key","p":["A brain key is a long passphrase that provides enough entropy to generate cryptographic keys. The suggestBrainKey function returns a brain key along with the corresponding private and public keys.","Using a brain key, you can regenerate the same key pairs whenever needed, provided the exact same mnemonic phrase is used. This is especially useful in scenarios requiring backup and recovery of cryptographic keys, ensuring they are never permanently lost.","Output","Always save the generated private keys and password securely. These keys provide access to your Hive account and assets. You can import them into the Beekeeper or any other supported Hive wallet to ensure that you can use them securely for transactions and other operations without exposing the raw keys."]}],[{"l":"Hive Protocol: Transaction and Operations","p":["Hive transactions, operations and their properties (i.e. assets) are represented using specific types and data structures defined inside the Hive Protocol library. These objects are initially defined using Protobuf, and language-specific versions are generated from the Protobuf code. This standardized representation allows for seamless integration and interoperability among various services and tools within the ecosystem."]},{"l":"Transactions","p":["Hive transactions are created by a user to group a sequence of Hive operations that should all succeed or fail together. Even singular operations need to be put inside a transaction because account signing is also performed at the transaction level. In addition to a sequence of operations, each transaction contains metadata such as the expiration time."]},{"l":"Transaction as Proof of Stake (TaPoS)","p":["The hive software requires every transaction to include part of the hash of a recent block header. This hash serves two purposes:","prevents a replay of a transaction on forks that do not include the referenced block","signals the network that a particular user and their stake are on a specific fork.","Over time all users end up directly confirming the blockchain which makes it difficult to forge counterfeit chains as the counterfeit would not be able to migrate transactions from the legitimate chain."]},{"l":"Transaction general structure","p":["ref_block_num: A 16-bit integer referencing the block number.","ref_block_prefix: A 32-bit integer referencing the block prefix.","expiration: A timestamp indicating when the transaction expires.","operations: A list of operations that are part of the transaction.","extensions: Additional data or extensions provided in the transaction.","signatures: A list of cryptographic signatures generated for given transaction. Can be empty for unsigned transactions."]},{"l":"Operations","p":[": Handles posting or editing content.",": Handles token transfers between accounts.",": Handles voting on content.","amount: The amount to be transferred.","author: The account name of the author.","author: The account name of the post author.","body: The content body.","from: The sender's account name.","Here are some examples of the contents of some operations:","json_metadata: Additional metadata in JSON format.","memo: An optional memo for the transfer.","Operations are commands to the blockchain processing engine. Example operations include transferring tokens, adding text posts to the blockchain, voting for posts, voting for witnesses, etc.","parent_author: The account name of the parent post author (for comments).","parent_permlink: The permanent link to the parent content.","permlink: The permanent link to the content.","title: The title of the post.","to: The receiver's account name.","voter: The account name of the voter.","weight: The weight of the vote.","You can find a full list of possible of operations and their fields in the Hive Wiki."]},{"l":"Implementation Note: Why use Protobuf?","p":["Protobuf (Protocol Buffers) is a language-neutral and platform-neutral mechanism for serializing structured data. Hive uses Protobuf definitions for transaction and operation data structures in order to make it easy to document and share these structures across different languages and platforms. These common definitions enable safe and rapid update to the Hive protocol while ensuring that different implementations (like those in the Wax library) are correctly aligned with the blockchain network's protocol standard.","Protobuf Definitions:","These definitions describe the data structures in a language-agnostic way.","They are defined directly inside the Hive Protocol library and shared from there","Examples:"]}],[{"l":"NaiAsset objects","p":["There are three asset types (token types) in Hive's layer 1 protocol: HIVE (liquid hive), VESTS (staked hive), and HBD (hive-backed dollars). All asset amounts are specified as fixed-point numbers to prevent rounding errors (these are especially problematic for financial calculations) . Hive and HBD use 3 digits of precision, VESTS are specified using 6 digits of precision.","Assets can be represented using two formats. The first is the deprecated string format. Here's an example of the deprecated format for 1 Hive token: 1.000 HIVE.","The second format is called Numeric Asset Identifier (NAI). NAI is the recommended format. With NAIs, asset types are specified using numbers rather than strings. NAIs were introduced to simplify supporting user-created asset types in the future.","Here's an example of an NAI asset for 1 hive token: {amount:1000,precision:3,nai:@@000000021}."]},{"l":"NAI format specifics","p":["NAI amount must be specified as integer value (no decimal point) and the precision is used to shift the decimal place appropriately.","The nai field is used to specify the asset type: 21 is HIVE, 37 is VESTS, and 13 is HBD.","precision is fixed for each asset type ( 3 or 6 for native tokens), so when creating NAI objects, only the integer quantity and type must be specified."]},{"l":"Creating NaiAsset objects for each asset type"}],[{"l":"Asset creation function details","p":["There are two primary methods to generate hive, vests, or hbd, categorized based on the type of input they accept."]},{"l":"Coins Functions","p":["Using this function, if you want to generate exactly one HIVE ( 1.000 HIVE), pass 1 as a value.","These functions are designed to handle floating-point numbers using JavaScript's double-precision floating-point format (IEEE 754). They can accept fractional values but are limited to numbers within JavaScript's precision bounds (i.e., not exceeding 2^53 - 1 or below -(2^53 - 1)).","Please be mindful of the maximum fractional parts that each asset can accept: 3 for hive and hbd, and 6 for vests.","If you provide fewer fractional parts than the asset can accept, they will be extended with implicit zeros, making it equivalent to providing the maximum number of fractional parts, as shown in the example above.","If you provide more fractional parts than the asset can accept, they will be cut to the acceptable precision, as shown in the example below."]},{"l":"Satoshis Functions","p":["These functions accept only integer values and do not perform any conversion on the input, other than adding a NaiAsset ID. They are capable of handling very large integers, and large string representations of numbers.","Using this function, if you want to generate exactly one HIVE ( 1.000 HIVE), pass 1000 as a value ( 1 * (10 to the power of asset precision), which for HIVE is 1 * (10 ** 3)).","In JavaScript, you can provide large numbers using the BigInt interface","As you can see, this means hiveSatoshis(1000) call equals hiveCoins(1)."]},{"l":"coins vs satoshis","p":["When choosing the appropriate function to generate an amount, consider the input type. Use the satoshis methods for large integer values. For floating-point numbers, choose the coins methods. It's preferable to use coins when working with scripts containing known, hardcoded amounts, while satoshis is better suited for API interactions or when amounts are provided by a user."]}],[{"l":"Asset Conversions","p":["Asset conversions are required for various Hive financial transactions. The @hiveio/wax library provides methods like VESTS to HP and HBD to Hive to facilitate these conversions."]},{"l":"VESTS to HP conversion","p":["This method converts VESTS into Hive Power (HP). This conversion requires three NaiAsset instances or values convertible to NaiAsset(number, string or bigint for JavaScript): one for the VESTS and two others for the total vesting fund Hive and total vesting shares.","This method takes 3 parameters:","vests: The amount of VESTS to convert.","total vesting fund: The total amount of Hive in the vesting fund (Retrieved from the database_api.get_dynamic_global_properties API call - total_vesting_fund_hive property).","total vesting shares: The total amount of vesting shares (Retrieved from the database_api.get_dynamic_global_properties API call - total_vesting_shares property).","You can also perform the reverse conversion from HP to VESTS using the hpToVests method."]},{"l":"HBD to HIVE conversion","p":["This method converts HBD into Hive. This conversion requires three NaiAsset instances or values convertible to NaiAsset(number, string or bigint for JavaScript): one for the HBD, one for the base (another HBD asset), and one for the quote (a HIVE asset).","This method takes 3 parameters:","hbd: The amount of HBD to convert.","base: The base asset (Retrieved from the database_api.get_current_price_feed API call - base property).","quote: The quote asset (Retrieved from the database_api.get_current_price_feed API call - quote property).","You can also perform the reverse conversion from HIVE to HBD using the hiveToHbd method."]}],[{"l":"Transactions","p":["A ITransaction is an interface for building, signing, and validating transactions.","The ITransaction in the Hive Ecosystem, provided by the Wax library, is a tool for creating and managing transactions on the Hive blockchain. It offers functionalities for building, signing, validating, and converting transactions."]},{"l":"Transaction signing","p":["Signing a transaction is a crucial step in ensuring its authenticity and integrity. The ITransaction interface provides methods for signing transactions using dedicated signers. This process involves creating a digital signature that verifies the transaction's origin and prevents tampering.","In our examples, we used a Beekeeper package that provides security in storing your keys. With it, you can easily import keys stored in your wallet and use them to sign transaction digests (signing-ready hashes). Beekeeper is available in multiple languages:","TypeScript: @hiveio/beekeeper","Python: TBA","In our test environment, we have used Beekeeper in runner.js. Thanks to this functionality, to execute code examples, you can utilize specific functionalities of Beekeeper (wallet, privateKey, etc.) by simply destructuring the object available in globalThis:","You can also use any other signer to sign transactions instead of signer1 or signer2.","We used Beekeeper in our examples for its simplicitly and security in handling private keys in multiple environments (Node.js, browser, etc.)."]}],[{"l":"Creating a Transaction","p":["The code below shows how to create a new transaction, having TaPoS (reference block) data automatically fetched from the remote Hive API endpoint. This implicitly creates an instance of Online transaction:"]}],[{"l":"Working with Transaction","p":["Basic purpose of ITransaction interface is adding new operations to the (just created) transaction. Depending on complexity of given blockchain usage scenario, you can either use a simple operation (directly correspondending to blockchain data type) or use dedicated complex operation class that covers the complex details (at blockchain side) and simplifies usage. In addition to this active part, the ITransaction interface also allows you to perform a data analysis within the provided blockchain transaction: query its digest (transaction id), acquire required authorities like also list signatures specified for given transaction, and finally querying for all the public keys used to make given signatures."]}],[{"l":"Pushing simple operation","p":["If your case is to perform simple actions on your transaction or create a new transaction, you can use initialization with the wax base interface.","However it is recommended to use chain initialization due to automatic TaPos data fetching (and so we do in the example code below).","Below is an example of fully building a simple transaction using the basic ITransaction interface.","Output"]}],[{"l":"Adding complex operations","p":["Complex usage of ITransaction interface allows to:","manually initialize transaction object with some blockchain properties (like TaPoS)","use provided operation factory classes which encapsulate blockchain complexity (this part operates on any transaction object - regardless of way how you obtained it)","Below is a complete example of a blockchain operation, requiring explicit serialization of input data to properly build final operation. All such steps require complex knowledge of blockchain internals and have been adopted to \"regular programming steps\".","Here we utilize WitnessSetPropertiesOperation class to build a complex operation using simple interface:","Output","As usually, the \"push operation\" method allows you to push any operation (regadless to complexity related to given blockchain scenario, being encapsulated by used operation class). At the end, the \"push operation\" method returns an instance of ITransaction interface, on which you can later perform operations related to the transaction. It nicely reuses well known scheme: Call-chain","More complex information about pushOperation are presented in subsequent chapters."]}],[{"l":"Reading transaction properties","p":["The ITransaction interface also allows you to read your transaction properties like sig digest, id, etc.","Output"]}],[{"l":"Working with Online Transaction","p":["The Online Transaction class extends the standard ITransaction interface implementation by adding functionality that requires chain API access. This provides enhanced verification capabilities and enables several important online transaction features that aren't available in offline transactions (such as created from TaPoS data, or directly using Protobuf or JSON objects)."]},{"l":"Overview","p":["The Online Transaction class:","Inherits from the base ITransaction class","Adds online-specific functionality for chain verification","Enables security checks for operations to prevent accidental key leaks","Verifies account existence and authority requirements"]},{"l":"On-Chain Verification","p":["One of the most powerful features of Online Transaction is the ability to perform on-chain verification:","TBA","This verification process includes:","Scanning for potential private key leaks in memos and comments","Ensuring referenced accounts exist on the blockchain","Validating authority changes in account operations","This verification process is automatically performed only on online transactions before broadcasting them. This way, you won't have to manually perform on-chain verification every time before broadcasting."]},{"l":"On-Chain Operation Validation","p":["The Online Transaction uses an internal on-chain operation validator class that performs various security checks:","Private Key Leak Prevention: Scans operation content (like memos and comments) for accidental inclusion of private keys","Account Existence Verification: Ensures referenced accounts exist on the blockchain","Authority Modification Safety: Checks for potentially dangerous authority changes","Example of what this prevents:","TBA"]},{"l":"Authority Verification Trace","p":["For debugging or advanced use cases, you can generate a detailed trace of authority verification:","Output","TBA","The trace can help understand:","Which signatures were used","Which authorities were satisfied","What authorities are still missing","The full verification path through nested authorities","By utilizing these features, we were able to create the Transaction Inspector app:","Transaction Inspector UI"]}],[{"l":"Binary representation of transaction","p":["The ITransaction interface also supports conversion to and from binary formats. This means you can easily serialize and deserialize transaction objects for efficient storage or deep analysis."]},{"l":"Overview","p":["The ITransaction interface provides methods for:","Serializing transaction objects to binary format","Serializing transaction objects to binary metadata format, describing their structure and fields","Deserializing binary data back into transaction objects","Thanks to those capabilities, we were able to create the Binary View Component (available through the Transaction Inspector app):","Binary view UI"]},{"l":"What is Binary Format","p":["The binary format of a transaction is a compact, serialized byte representation of all transaction data following Hive's binary serialization protocol. This format:","Represents all transaction fields and operations in a compact binary form","Is used internally by Hive nodes for transaction processing and blockchain storage","Provides a more network-efficient way to transmit transactions compared to JSON","Serves as the canonical format for transaction signature generation","Contains fixed-length and variable-length fields according to Hive's binary serialization rules","Understanding binary format is essential when working with transaction signatures, blockchain explorers, and low-level Hive tools."]},{"l":"HF26 and Legacy Format Considerations","p":["Hive implemented significant changes to the transaction format in Hardfork 26 (HF26). This affects binary serialization in the following ways:","Pre-HF26 (Legacy): Operations are serialized as paired arrays [optype, {...params}]","Post-HF26 (Modern): Operations are serialized as objects with type and value fields {type: optype_operation, value: {...params}}","When working with binary transactions, you must be aware of which format is expected by the tools or nodes you're interacting with. The WAX library provides methods for both formats:","toBinaryForm()- Returns the modern binary format","There are also considerations when calculating transaction digests for signing (see below)","The binary format directly impacts transaction signatures because signatures are calculated based on the transaction digest (hash of binary data)."]},{"l":"Conversion to binary format","p":["With this conversion method, you can decide to strip to the unsigned transaction, which removes any information about the signatures container (by default the signatures container is present):","Output","TBA"]},{"l":"Retrieving transaction binary metadata","p":["You can also retrieve the binary metadata, which in details describes the structure and fields of the transaction, along their size and offset in bytes:","Output","TBA"]},{"l":"Deserializing tranasction","p":["This feature can be useful if you are reading transactions directly as a stream of bytes, previously serialized. We are already using transaction in binary form in plenty of Hive apps, such as: HAfAH, hived, etc.","Output","TBA"]}],[{"l":"Finalization","p":["When the work with the transaction is ready, you now need to decide what you want to do with it next."]},{"l":"Conversion to api form","p":["The simple toApi method returns the transaction in the Hive API-JSON form:","Output","You can also represent your transaction in the API form, with your signature added to the internal signatures array (it will also apply the transaction expiration time):","Also remember that you can add more than one signature while signing your transaction.","If you want to sign your transaction in traditional way and return it in the API form, you can use this sample (it will also apply the transaction expiration time):","You can also sign the transaction without converting it to the API form (which will return the signatures):","If you want to sign the transaction after creating it, using our ITransaction interface, you should use one of the available signers. Remember to import keys into Beekeeper. It ensures that you can use them securely for transactions and other operations without exposing the raw keys.","Imported key and the one you want to use for signing must be the same!"]},{"l":"Conversions","p":["At the end you can also just convert your transaction into the Hive API-form JSON:","Output","Or you can just convert transction to legacy API form:"]}],[{"l":"Hive Apps Operations in Transaction interface","p":["The Hive blockchain enables advanced operations using . These operations are standardized and recognized by the Hive Ecosystem, such as Hivemind. This allows us to utilize advanced features that go beyond typical Hive blockchain operations. These custom operations are known as Hive Apps operations."]},{"l":"What is a Hive Apps Operation?","p":["A Hive Apps operation is essentially a operation. Through these operations, we can execute custom actions on the Hive blockchain which are recognized and processed by the Hive infrastructure, like Hivemind."]},{"l":"Creating Hive Apps Operations","p":["To facilitate the construction and management of these operations, we use the Hive Apps Operation classes. Below are specific classes for different types of Hive Apps operations:"]},{"l":"1. Resource Credits Operation","p":["This operation class is used to manage Resource Credits (RC) delegations. Resource Credits allow actions to be performed on the Hive blockchain without paying transaction fees."]},{"l":"Example RC usage","p":["If you want to help a friend perform more operations on their account, you can delegate some of your Resource Credits to them. Meanwhile the other friends does not need your help anymore, so you can remove the delegation.","Output","Not implemented yet— planned for a future release."]},{"l":"2. Follow Operation","p":["This operation class handles operations related to following, muting, blacklisting blogs, and reblogging posts."]},{"l":"Example follow usage","p":["Output","Not implemented yet— planned for a future release."]},{"l":"3. Community Operation","p":["This operation class manages operations specific to communities on the Hive blockchain."]},{"l":"Example community Usage"},{"l":"Community member","p":["You want to join a specific community to stay updated with its content and you want flag some post. Here is an example how you can do it:","Output","Not implemented yet— planned for a future release."]},{"l":"Updating Community Properties","p":["Since you are an community administrator, you can update its properties:","Output","Not implemented yet— planned for a future release.","Remember to always authorize your operations. The account that authorizes the operation also must sign the transaction(as shown in the first example)."]},{"l":"Summary","p":["Hive Apps operations enable the execution of complex tasks on the Hive blockchain using . By utilizing the appropriate operation classes, users and developers can efficiently create, manage, and authorize these operations, ensuring smooth and standardized interactions in the Hive ecosystem. This simplifies and automates the management of communities, resource credits, and subscriptions."]}],[{"l":"Example Transaction interface usage","p":["Once you know all the ITransaction interface functionality, let's look at an example of complete usage."]},{"l":"Example usage (HF26 format)","p":["In this example we will create a transaction with two operations: and . We will sign it using two different keys (multi-signing) leveraging signers functionality.","Output","Please note that the output for txSigned and txMultiSigned is not complete due to its complexity. Only the signatures field is presented. You can see the full output in the console by testing it yourself."]},{"l":"Example usage (Legacy format)","p":["In this example we will create a transaction with one . We will sign it using one key.","Because the legacy format is considered deprecated, the example below is for educational purposes only. We recommend using the HF26 format for creating and managing transactions. Due to the deprecated status of the legacy format, signers do not support signing transactions in legacy format. Therefore, in this example, we will use a raw Beekeeper wallet to sign the transaction digest.","Output","Also if you want to use some custom tool for signing the transaction instead of our provided methods, you can do it based on the sample above. If you do not want to use ITransaction interface in legacy form, you can do it just by replacing:","const digest = tx.legacy_sigDigest;-> const digest = tx.sigDigest;.","The legacy transaction format is deprecated— wax-python no longer supports this conversion."]},{"l":"Full Transaction interface example usage","p":["Output"]}],[{"l":"Advanced usage","p":["If you want to use the advanced features of the ITransaction interface you can initalize it using dedicated methods:"]},{"l":"Initialization with explicit TaPoS and expiration time","p":["Creating transaction with TaPoS can be useful for cases when you would like to perform batch operations without any access to remote Hive API calls.","Due to long TaPoS lifespan (near to 64000 blocks, so it really targets to the c.a. 53 hours), you can easily receive TaPoS data (reference block-id) once from blockchain and next reuse it in your code generating massive transactions, to finally sign and broadcast them:"]},{"l":"Initialization from hive API-JSON form","p":["This can be useful for analyzing transactions retrieved from the API or restored previously from the API form."]},{"l":"Initialize from protobuf transaction","p":["This can be useful for analyzing transactions restored previously from the protobuf form."]}],[{"l":"Comment-reply and Post operations","p":["One of the complex operations supported by the Hive blockchain is the publishing of blog posts and replies (comments) to them. To simplify it, the Wax library provides specific helper operation factory classes: Blog Post Operation and Reply Operation. Below, we provide snippets for creating blog posts and replies including scenarios where additional properties are defined. These scenarios internally involve an additional blockchain operation called .","This complex operations generate only if user provided values different from the defaults."]},{"l":"Creating a blog post with custom JSON-metadata properties","p":["Not implemented yet— planned for a future release."]},{"l":"Creating a Comment (Reply) with multiple JSON-metadata attributes","p":["You can set multiple properties on one operation class instance, as shown in the example below.","Not implemented yet— planned for a future release."]}],[{"l":"Using RecurrentTransfer","p":["The Recurrent Transfer Operation allows for initiating, modifying, and removing recurrent transfers on the Hive blockchain."]},{"l":"Creating a new Recurrent Transfer","p":["Not implemented yet— planned for a future release."]},{"l":"Generate Removal Using Recurrent Transfer Operation","p":["Generate removal removes recurrent transfer:","Not implemented yet— planned for a future release."]},{"l":"Add Pair Id","p":["In this example we add pair id to recurrent transfer, using Recurrent Transfer Operation (simply specify the pairId field in the configuration):","Not implemented yet— planned for a future release."]}],[{"l":"Using UpdateProposal","p":["The Update Proposal Operation allows for updating proposals on the Hive blockchain."]},{"l":"Performing a proposal update","p":["Not implemented yet— planned for a future release."]},{"l":"Adding an End Date to an Update Proposal","p":["Not implemented yet— planned for a future release."]}],[{"l":"Setting Witness Properties","p":["The Witness Set Properties Operation allows witnesses to update their properties on the Hive blockchain."]},{"l":"Setting Default Witness Properties","p":["Output"]},{"l":"Setting Explicit Witness Properties","p":["As with all operation classes, you can set all the optional fields on a single class instance.","Output"]}],[{"l":"Account authority update","p":["Another troublesome operation offered by Hive Blockchain is dedicated to changing account authority. To simplify blockchain implementation, this operation must contain a whole authority role specification (for the owner, active, posting roles), because it overwrites it in the blockchain account representation. So missing some part of current authority definitions leads to dramatic scenarios when account authority definition can be broken. To simplify this process, wax library offers Account Authority Update meta operation which is responsible for collecting initial set of authority definitions and next allows to modify them by adding/removing/replacing authority entries.","Another important feature of this operation is tracking changes in the authority objects. Actual blockchain operation will be generated only if the authority object has been effectively changed according to initially loaded state.","To prevent errors when actual generation is skipped, the Account Authority Update class offers isEffective property, which allows the caller to determine if any further transaction processing is needed.","UI developers can be also interested in direct use of the Account Authority Update operation as their intermediate data storage specific to UI, because:","it offers a way to iterate over the authority objects and display them in a user-friendly way (needed to initially supply the view)","provides basic editing capabilities by mentioned above entry specific methods ( add/replace/remove/reset), like also additional reset() method being useful for canceling changes in the authority editor view.","allows to determine data modification state by isEffective property, what can be useful in displaying a dirty state in the view"]},{"l":"Online operations","p":["Account authority update operation is one of the \"Online operations\", which initially require online access to the live blockchain in order to work.","We have to parse your current authority data in order to create a new, valid authority object."]},{"l":"Role categories and levels concept","p":["Role category is a container for given set of role levels. The idea behind it, is to leave an open way for creating another role categories definitions in the future, once Hive Blockchain will support them. Thus, even set of role categories evolves, you can still use the same Account Authority Update class to manage them.","Role category can describe authorities saved as custom JSONs, comment JSON metadata, user metadata or base hive authorities. Role category can be a set of authorities used in, for example: your on-blockchain game or service.","In given role category you can create multiple levels of authorities. Given the base hive role category, we have 4 base levels - active, posting, owner and memo.","We currently support only the hive role category."]},{"l":"Setting new memo key on the profile"},{"l":"Adding account proxy to the posting role definition","p":["Sometimes you want to allow a separate account to operate on behalf of your account (e.g., a bot, backup account, or trusted service). To define such authority proxy, you can use the AccountAuthorityUpdateOperation by calling its add(account: TAccountName, weight: number = 1) method. The important aspect is matching the account weight to the role threshold - only entries with weights equal or greater than the role threshold will be able to authorize operations and satisfy the authority."]},{"l":"Changing active key"},{"l":"Modifying the owner level with threshold change"},{"l":"Iterating over the hive category roles"}],[{"l":"Encrypt buffer","p":["The Wax library provides a robust set of tools for handling encryption and decryption within the Hive ecosystem. This includes both methods for direct encryption/decryption as well as using the ITransaction interface to handle encrypted operations.","One important detail to note is that public keys within the Hive ecosystem start with the prefix STM."]},{"l":"Using Direct Encryption and Decryption Methods","p":["The signer's encryptData and decryptData methods allow for straightforward encryption and decryption operations with explicit public keys. You provide the content as a string to be encrypted/decrypted, and the public key(s) used for encryption/decryption. Below are examples covering the case with one and two keys (sender key and receiver key):"]},{"l":"One key encryption","p":["Not implemented yet— planned for a future release."]},{"l":"Two keys encryption","p":["Not implemented yet— planned for a future release.","A second public key is passed to the encryption method in this example for later use during decryption - matching public key to the private key in the wallet.","The public key you are providing to the signer's encryptData/ decryptData methods should correspond to private keys that are available in your signer instance. If the requested private key for the given public key is not found in the signer, an exception will be thrown."]}],[{"l":"Encrypt operations","p":["Wax provides a simple interface for encrypting operation data within a transaction using the ITransaction interface. Operation encrypting allows to push operations in transparent way, just by pushing markers when to start and stop encryption."]},{"l":"Operations That Can Be Encrypted","p":["Currently, Hive supports encrypting the following operation data:","- Encrypts the body field.","- Encrypts the json field. Custom JSON encryption is unique as it wraps the encrypted data in an encrypted key.","- Encrypts the memo field."]},{"l":"Encrypting Operations within a Transaction","p":["These examples demonstrate how to handle encryption and decryption using both direct methods and the ITransaction interface in the Wax library.","Actual encryption is performed while signing transaction!"]},{"l":"One key encryption","p":["startEncrypt only enables encryption for the operation data above, other data is not encrypted.","publicKey1 used for transaction signing can (and usually does) differ from the public key used for encryption.","Not implemented yet— planned for a future release."]},{"l":"Two keys encryption","p":["Not implemented yet— planned for a future release."]},{"l":"Mixed encryption","p":["publicKey1 used for transaction signing can (and usually does) differ from the public key used for encryption.","Not implemented yet— planned for a future release."]}],[{"l":"Signers","p":["Wax allows users to securely sign transactions and messages using their private keys. This process ensures that only the rightful owner of the keys can authorize actions on their behalf, providing a robust layer of security for user accounts and assets."]},{"l":"Supported Signers","p":["Wax provides a variety of signers to accommodate different user needs and preferences:","Software Signers: These are applications or libraries that manage private keys and facilitate signing transactions, encrypting operations & memos on behalf of the user. Examples include:","Beekeeper: A user-friendly, safe Web & Node.js wallet for managing Hive accounts and keys. Allows both: memo encryption & transaction signing,","hb-auth: A user-friendly, safe Web-only, Worker-based wallet, sharing state across multiple opened tabs for managing Hive accounts and keys. Allows transaction signing, authentication by verifying user authority at chain side,","MetaMask: A popular browser extension Hive Wallet Snap for managing accounts and keys. Allows both: memo encryption & transaction signing,","Keychain: A browser extension for managing Hive accounts and keys. Allows both: memo encryption & transaction signing,","PeakVault: A browser extension for managing Hive accounts and keys. Allows both: memo encryption & transaction signing.","Beekeeper: A user-friendly, safe Web & python wallet for managing Hive accounts and keys. Allows both: memo encryption & transaction signing."]}],[{"l":"Beekeeper","p":["Wax signer library extending transaction signing possibilities by a safe wallet - Beekeeper"]},{"l":"Install package","p":["View Beekeeper signer package on npmjs \uD83E\uDC6D"]},{"l":"Usage"}],[{"l":"HB Auth","p":["Wax signer library extending transaction signing possibilities by a 3rd party Web-only extension - hb-auth."]},{"l":"Install package","p":["View HB Auth signer package on npmjs \uD83E\uDC6D"]},{"l":"Usage"}],[{"l":"MetaMask","p":["Wax signer library extending transaction signing possibilities by the Hive Wallet - a 3rd party Web-only MetaMask extension snap","We were able to leverage the MetaMask Snap SDK to create a Hive-compatible signer that works seamlessly with MetaMask. This integration allows users to manage their Hive accounts and sign transactions directly within the MetaMask interface, providing a familiar and secure experience for those already using MetaMask for Ethereum and other EVM-compatible chains: Official Hive Wallet Snap","Please read the Knowledge Base for more details on how to use the Hive Wallet Snap. You can also check out our official dApp - Hive Bridge."]},{"l":"Install package","p":["View MetaMask signer package on npmjs \uD83E\uDC6D"]},{"l":"Prerequisites","p":["Configured MetaMask wallet according to the tutorial"]},{"l":"Usage"}],[{"l":"Keychain","p":["Wax signer library extending transaction signing possibilities by a 3rd party Web-only extension - Keychain"]},{"l":"Install package","p":["View Keychain signer package on npmjs \uD83E\uDC6D"]},{"l":"Prerequisites","p":["Configured Keychain browser extension with imported keys"]},{"l":"Usage"}],[{"l":"PeakVault","p":["Wax signer library extending transaction signing possibilities by a 3rd party Web-only extension - Peak Vault"]},{"l":"Install package","p":["View PeakVault signer package on npmjs \uD83E\uDC6D"]},{"l":"Prerequisites","p":["Configured Peak Vault browser extension with imported keys"]},{"l":"Usage"}],[{"l":"Manabar types"},{"l":"Understanding Hive's Manabars and Resource Credits","p":["The Hive blockchain employs a unique system to manage user activities, particularly when it comes to voting, content creation, and resource utilization. This system leverages \"manabars,\" a visual representation of available resources, to ensure fair and efficient usage. Here we delve into the different types of manabars, their functionalities, and the intricacies of Resource Credits (RC)."]},{"l":"Manabars on Hive Blockchain","p":["Manabars on the Hive blockchain visually represent the remaining power for specific activities associated with an account. Let's explore the different types of manabars:","Voting Manabar: This indicates the available voting power of an account. Each time a user votes, a portion of the voting power is utilized and gradually regenerates over time.","Downvote Manabar: Similar to the voting manabar, this shows the power available for downvoting content. Downvotes consume a separate resource that also regenerates over time.","Resource Credits Manabar: This bar represents the available Resource Credits (RC) which are critical for executing various transactions on the blockchain. Every transaction consumes a portion of RC, which regenerates over time based on the account's stake."]},{"l":"How Manabars Work","p":["Resource Utilization: Every activity on the Hive blockchain, whether it's posting content, voting, or making transactions, uses up a certain amount of resource from the corresponding manabar.","Regeneration: The power consumed by these activities is not lost forever. Manabars regenerate to full capacity over time, ensuring that active users can continue participating in the network.","Proportional Limits: The amount of resources an account can consume is directly proportional to the amount of Hive Power (vested stake) they have. Higher vested users have more resources and faster regeneration rates."]},{"l":"Resource Credits Explained","p":["Resource Credits (RC) are a form of bandwidth on the Hive blockchain, and they are essential for executing transactions. Here's what you need to know about RC:","Non-Transferable: RCs are tied to individual Hive accounts and cannot be transferred or traded.","Regeneration: Similar to the manabars, RCs regenerate over time. The rate of regeneration is proportional to the Hive Power of the account.","Transaction Cost: Every transaction on the Hive blockchain consumes RCs. The more complex the transaction, the higher the RC cost.","Delegated RCs: Accounts with more RCs than needed can delegate a portion to others."]},{"l":"Examples","p":["Voting: When a user votes on a post, the voting manabar is depleted according to the vote weight. The depleted energy will start to regenerate over time.","Posting Content: Creating a post or comment consumes RC proportional to the resource requirements, which include CPU cycles, state memory, and history size.","Account Creation: Creating new accounts on Hive has a significant RC cost due to the resources it consumes."]},{"l":"Visual Representation","p":["Here's a typical view of a manabar on the Hive blockchain:","Manabars visualization example on Hive Block Explorer"]}],[{"l":"Manabar calculations","p":["Manabars in the Hive ecosystem represent the available resources for different activities such as upvoting, downvoting, and resource credits (RC). Each type of manabar regenerates over time and is pivotal in understanding an account's capacity to perform these activities."]},{"l":"Common Parameters for Manabar Calculation for Wax Base interface","p":["The calculations for each type of manabar follow a similar methodology, and they require some common parameters:","now: Current head block time. (Timestamp in seconds)","maxMana: Maximum account mana. Can be any numeric type, string or BigInt*","currentMana: Current account mana. Can be any numeric type, string or BigInt*","lastUpdateTime: Last update time of the current mana (in seconds)","* - (Only in JavaScript for large numbers)"]},{"l":"Calculation Methods using Wax Base Interface"},{"l":"Upvote Manabar Calculation","p":["To calculate the upvote manabar, you need to gather the following values:","now: Can be obtained using the time property from the dynamic global properties.","maxMana: Equivalent to post_voting_power.amount from the find_account API call.","currentMana: Equivalent to voting_manabar.current_mana from the find_account API call.","lastUpdateTime: Equivalent to voting_manabar.last_update_time from the find_account API call"]},{"l":"Downvote Manabar Calculation","p":["To calculate the downvote manabar, you need to gather the following values:","now: Can be obtained using the time property from the dynamic global properties.","maxMana: Equivalent to post_voting_power.amount multiplied by downvote_pool_percent from the dynamic global properties.","currentMana: Equivalent to downvote_manabar.current_mana from the find_account API call.","lastUpdateTime: Equivalent to downvote_manabar.current_mana from the find_account API call."]},{"l":"RC Manabar Calculation","p":["To calculate the RC manabar, you need to gather the following values:","now: Can be obtained using the time property from the dynamic global properties.","maxMana: Equivalent to max_rc value from the rc_accounts API call.","currentMana: Equivalent to rc_manabar.current_mana from the rc_accounts API call.","lastUpdateTime: Equivalent to rc_manabar.last_update_time from the rc_accounts API call.","Manabar calculations are sensitive to the latest blockchain state. Always fetch up-to-date dynamic global properties via API calls when using Wax Base interface. Wax Chain interface can automatically fetch required resources from the network using specified API endpoint."]},{"l":"Example Usage","p":["You can also calculate the manabar values using high-level Wax Chain interface that automatically parses mentioned values from the chain and uses them for calculation for requested account."]},{"l":"Calculation of Upvote Manabar for an Account"},{"l":"Calculation of Full Regeneration Time for Downvote Manabar"},{"l":"Calculation of Full Regeneration Time for Resource Credits Manabar","p":["Function calculateManabarFullRegenerationTimeForAccount returns a JavaScript Date object, which can be easily processed.","calculateCurrentManabarValueForAccount returns an object with manabar values and percent loaded."]}],[{"l":"Preface","p":["Operation formatters provide a mechanism for converting complex operation objects into human-readable text representations."]},{"l":"How Formatters Work","p":["Formatters work by taking operation objects (such as transactions, custom JSON operations, NAI assets, witness properties etc.) and transforming them into strings or objects based on predefined or custom formatting rules. The formatting rules can match specific properties or types within the operation objects and then apply the necessary transformations."]},{"l":"Regular Usage","p":["Wax transformers traverse given object from the bottom to the top without modifying the input data, e.g. in the following object, properties will be matched in the following order: 'a', 'b', 'c':"]}],[{"l":"Blockchain Data Formatters"},{"l":"Formatting a large number","p":["Using Wax Formatters, you can format numbers represented as string, number, BigInt using formatNumber method","Output","Not implemented yet— planned for a future release."]},{"l":"Formatting NAI Asset","p":["If you want to format a string, use waxify literal","Output","Not implemented yet— planned for a future release."]},{"l":"Formatting Transaction","p":["Output","Not implemented yet— planned for a future release."]},{"l":"Formatting entire transaction without replacing with transaction id","p":["Sometimes there is a need to convert an entire transaction object, but you do not want it to be replaced with the string. You can achieve that by using format method and extending the default Wax Formatter with your custom options, e.g.:","Output","Not implemented yet— planned for a future release."]}],[{"l":"Operation Formatters"},{"l":"Formatting RC delegation operations","p":["Output","Not implemented yet— planned for a future release."]},{"l":"Formatting community operations","p":["Output","Not implemented yet— planned for a future release."]},{"l":"Formatting follow operations","p":["Output","Not implemented yet— planned for a future release."]},{"l":"Formatting witness properties object","p":["You can also parse the serialized operation - props property from the chain:","Output","Not implemented yet— planned for a future release."]}],[{"l":"Extending formatter","p":["Operation formatters may be easily extended for formatting other operation types and Hive-related structures using WaxFormattable TypeScript decorator.","@WaxFormattable() decorator specifies a custom formatter class method as a \"formatter method\" that matches objects with a given property name, by value or by instance of and transforms them. The property name can be specified in the decorator arguments as a string, as a property option or it defaults to the method name as the property name to match. By this, you can avoid problems like matching \"get\" or \"constructor\" properties.","Additionally, the new formatters are designed using reflect-metadata library, so if you have a method in the formatter class that does not have the mentioned decorator, then it will not be taken into account when formatting properties.","Options for the main formatter instance are passed to your custom formatter functions along the source and target objects, so you can also adapt your code to previously defined options.","You should not modify source and target values passed to the formatter functions. The target object will be formatted properly based on the formatter functions return value","Inside the formatter method specific to the given property, there will be passed an object as a first argument with readonly properties:","options- Formatter options","source- Source readonly unchanged input value for parsing raw data","target- Target formatter data that might have been previously changed by other formatters","Upon leaving the function scope, you may return the value other than undefined if you want to change the matched property to the given data.","Not implemented yet— planned for a future release."]},{"l":"Regular Usage"},{"l":"Matching property name by the function name","p":["Output","Not implemented yet— planned for a future release."]},{"l":"Matching property name and value for operation formatting","p":["Output","Not implemented yet— planned for a future release."]},{"l":"Matching property instance of for hive apps operation formatting","p":["Output","Not implemented yet— planned for a future release."]}],[{"l":"Using default APIs","p":["Wax provides an object-oriented interface for making and verifying API requests and responses. Hive API requests are arranged into various API categories:","account_by_key_api: API requests related to reading account keys,","block_api: API requests for fetching blockchain blocks,","database_api: API requests for reading Hive state information,","network_broadcast_api: API requests for broadcasting transactions to write to the blockchain,","rc_api: API requests for reading/analyzing resource constraints (rc),","etc."]},{"l":"Regular Usage","p":["The syntax for making an API call is:"]},{"l":"Fetching the first blockchain block","p":["Using chain interface, you can retrieve a blockchain block. In the example below we use block_api as apiType and get_block as apiMethod:","Output"]},{"l":"Changing Wax root's API server (endpointUrl)","p":["Sometimes you may want to call database_api from a local API endpoint, while get_block from some of the well-known API endpoint URLs. You can achieve it setting the endpointUrl property as in the example below:","Output","Not implemented yet — planned for a future release."]}],[{"l":"Extending Chain","p":["When writing an advanced Hive blockchain application, you may want to add more APIs to the standard set of Wax methods. There is a feature in Wax called extend or extendRest(for REST API) allowing you to extend Wax Chain with fully-typed requests with full typization.","Wax extended using HAfAH REST API package - Full IntelliSense support"]},{"l":"Manually extending JSON-RPC API","p":["Output","As you can see in the example, there is a type called: TWaxApiRequest which as a first template argument takes a user input type (that the user will have to pass to the API request function). It may be an interface, but it can also be a standard type, like: boolean, number, Array and so on. The second argument should be the response type (type of result in the snippet above)."]},{"l":"Manually extending REST API","p":["Output"]},{"l":"Automatically extending API","p":["Thanks to the OpenAPI specifications, we can automatically generate API definitions for both JSON-RPC and REST API. This way you don't have to manually define each method, its parameters, and return types. If you have your own API with OpenAPI spec, you can also automatically generate the types and use them with Wax.","When dealing with TypeScript and JavaScript, you can use the following package to automatically generate types from OpenAPI spec:","View WAX Spec Generator package on npmjs \uD83E\uDC6D","TBA"]},{"l":"Use JSON-RPC API packages","p":["For basic wax usage, the default API methods, shipped with the package are usually sufficient. However, if you want to use more advanced API methods, you can extend the default API with additional methods. Defining a whole set of methods can be tedious, so Wax provides a way to automatically extend the API with additional methods, using the extend method and external packages with automatically generated spec from OpenAPI.","View JSON-RPC API package on npmjs \uD83E\uDC6D","Example usage:","TBA"]},{"l":"Use REST API packages","p":["As you can see it is a little complicated and REST API can potentially change frequently as it is not consensus-based, so we created multiple packages, automatically generating API definitions from OpenAPI definitions for each endpoint. You would only need to install the package and use the generated types:","View HAfAH API package on npmjs \uD83E\uDC6D View Block Explorer API package on npmjs \uD83E\uDC6D View Reputation Tracker API package on npmjs \uD83E\uDC6D View Balance Tracker API package on npmjs \uD83E\uDC6D","Example usage:","HAfAH: wax-api-hafah","Block Explorer: wax-api-hafbe","Reputation Tracker: wax-api-reputation-tracker","Balance Tracker: wax-api-balance-tracker","Output:"]}],[{"l":"Thank You for Exploring Wax","p":["We hope this documentation has been helpful in your journey with the Wax library for Hive blockchain development. Your feedback and contributions are valuable to us!"]},{"l":"Stay Connected","p":["\uD83D\uDCAC Developer Chat: Join us on openhive.chat using your Hive account (Recommended)","\uD83D\uDCF1 Community: Connect with the broader Hive community on Telegram(Please avoid sharing sensitive information)","\uD83D\uDC1E Report Issues: Submit bugs or feature requests on Wax GitLab"]},{"l":"Additional Resources","p":["\uD83D\uDCDA Hive Developer Portal- Official developer resources for the Hive ecosystem","\uD83C\uDF10 Hive Block Explorer- Explore Hive transactions and accounts","\uD83D\uDD0D API Documentation- Swagger reference for the Hive REST API endpoints","\uD83E\uDDEA Transaction Inspector- Analyze and debug your Hive transactions"]},{"l":"Contributing","p":["We welcome contributions to both this documentation and the Wax library.","Thank you for being part of our community! Happy coding! \uD83D\uDE80"]}]]